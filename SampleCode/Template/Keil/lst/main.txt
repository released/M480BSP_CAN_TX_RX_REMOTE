; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -I..\..\Template -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=528 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.CAN0_IRQHandler||, CODE, READONLY, ALIGN=2

                  CAN0_IRQHandler PROC
;;;417      */
;;;418    void CAN_DEVICE_IRQ(void)
000000  4801              LDR      r0,|L1.8|
;;;419    {
;;;420    //	printf("%s \r\n",__FUNCTION__);
;;;421    	CAN_IRQHandler(CAN_DEVICE_PORT);
000002  f7ffbffe          B.W      CAN_IRQHandler
;;;422    
;;;423    }
;;;424    
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      0x400a0000

                          AREA ||i.CAN_IRQHandler||, CODE, READONLY, ALIGN=2

                  CAN_IRQHandler PROC
;;;348    
;;;349    void CAN_IRQHandler(CAN_T *tCAN)
000000  b570              PUSH     {r4-r6,lr}
;;;350    {
;;;351        uint32_t u8IIDRstatus;
;;;352    
;;;353        u8IIDRstatus = CAN_GET_INT_PENDING_STATUS(tCAN);
000002  6905              LDR      r5,[r0,#0x10]
000004  4604              MOV      r4,r0                 ;350
;;;354    
;;;355        if(u8IIDRstatus == 0x00008000)        /* Check Status Interrupt Flag (Error status Int and Status change Int) */
000006  f5b54f00          CMP      r5,#0x8000
00000a  d00b              BEQ      |L2.36|
;;;356        {
;;;357            /**************************/
;;;358            /* Status Change interrupt*/
;;;359            /**************************/
;;;360            if(tCAN->STATUS & CAN_STATUS_RXOK_Msk)
;;;361            {
;;;362                tCAN->STATUS &= ~CAN_STATUS_RXOK_Msk;   /* Clear Rx Ok status*/
;;;363    
;;;364                printf("RX OK INT\n") ;
;;;365                while(!UART_IS_TX_EMPTY(UART0));
;;;366            }
;;;367    
;;;368            if(tCAN->STATUS & CAN_STATUS_TXOK_Msk)
;;;369            {
;;;370                tCAN->STATUS &= ~CAN_STATUS_TXOK_Msk;    /* Clear Tx Ok status*/
;;;371    
;;;372                printf("TX OK INT\n") ;
;;;373            }
;;;374    
;;;375            /**************************/
;;;376            /* Error Status interrupt */
;;;377            /**************************/
;;;378            if(tCAN->STATUS & CAN_STATUS_EWARN_Msk)
;;;379            {
;;;380                printf("EWARN INT\n") ;
;;;381            }
;;;382    
;;;383            if(tCAN->STATUS & CAN_STATUS_BOFF_Msk)
;;;384            {
;;;385                printf("BOFF INT\n") ;
;;;386    
;;;387                /* Do Init to release busoff pin */
;;;388                tCAN->CON = (CAN_CON_INIT_Msk | CAN_CON_CCE_Msk);
;;;389                tCAN->CON &= (~(CAN_CON_INIT_Msk | CAN_CON_CCE_Msk));
;;;390                while(tCAN->CON & CAN_CON_INIT_Msk);
;;;391            }
;;;392        }
;;;393        else if (u8IIDRstatus!=0)
00000c  2d00              CMP      r5,#0
00000e  d037              BEQ      |L2.128|
;;;394        {
;;;395    //        printf("=> Interrupt Pointer = %d\n",CAN_GET_INT_PENDING_STATUS(tCAN) -1);
;;;396    //        printf("=> Interrupt Pointer = %d\n",u8IIDRstatus -1);
;;;397    
;;;398            CAN_MsgInterrupt(tCAN, u8IIDRstatus);
000010  4629              MOV      r1,r5
000012  f7fffffe          BL       CAN_MsgInterrupt
000016  1e6d              SUBS     r5,r5,#1
;;;399    
;;;400    //        CAN_CLR_INT_PENDING_BIT(tCAN, (CAN_GET_INT_PENDING_STATUS(tCAN) -1));      /* Clear Interrupt Pending */
;;;401    		CAN_CLR_INT_PENDING_BIT(tCAN, (u8IIDRstatus -1)); 
000018  b2e9              UXTB     r1,r5
00001a  4620              MOV      r0,r4
00001c  e8bd4070          POP      {r4-r6,lr}
000020  f7ffbffe          B.W      CAN_CLR_INT_PENDING_BIT
                  |L2.36|
000024  6860              LDR      r0,[r4,#4]            ;360
000026  06c0              LSLS     r0,r0,#27             ;360
000028  d50a              BPL      |L2.64|
00002a  6860              LDR      r0,[r4,#4]            ;362
00002c  f0200010          BIC      r0,r0,#0x10           ;362
000030  6060              STR      r0,[r4,#4]            ;362
000032  a019              ADR      r0,|L2.152|
000034  f7fffffe          BL       __2printf
000038  481a              LDR      r0,|L2.164|
                  |L2.58|
00003a  6981              LDR      r1,[r0,#0x18]         ;365
00003c  00c9              LSLS     r1,r1,#3              ;365
00003e  d5fc              BPL      |L2.58|
                  |L2.64|
000040  6860              LDR      r0,[r4,#4]            ;368
000042  0700              LSLS     r0,r0,#28             ;368
000044  d506              BPL      |L2.84|
000046  6860              LDR      r0,[r4,#4]            ;370
000048  f0200008          BIC      r0,r0,#8              ;370
00004c  6060              STR      r0,[r4,#4]            ;370
00004e  a016              ADR      r0,|L2.168|
000050  f7fffffe          BL       __2printf
                  |L2.84|
000054  6860              LDR      r0,[r4,#4]            ;378
000056  0640              LSLS     r0,r0,#25             ;378
000058  d502              BPL      |L2.96|
00005a  a016              ADR      r0,|L2.180|
00005c  f7fffffe          BL       __2printf
                  |L2.96|
000060  6860              LDR      r0,[r4,#4]            ;383
000062  0600              LSLS     r0,r0,#24             ;383
000064  d50b              BPL      |L2.126|
000066  a016              ADR      r0,|L2.192|
000068  f7fffffe          BL       __2printf
00006c  2041              MOVS     r0,#0x41              ;388
00006e  6020              STR      r0,[r4,#0]            ;388
000070  6820              LDR      r0,[r4,#0]            ;389
000072  f0200041          BIC      r0,r0,#0x41           ;389
000076  6020              STR      r0,[r4,#0]            ;389
                  |L2.120|
000078  6820              LDR      r0,[r4,#0]            ;390
00007a  07c0              LSLS     r0,r0,#31             ;390
00007c  d1fc              BNE      |L2.120|
                  |L2.126|
;;;402    
;;;403        }
;;;404        else if(tCAN->WU_STATUS == 1)
;;;405        {
;;;406            printf("Wake up\n");
;;;407    
;;;408            tCAN->WU_STATUS = 0;                       /* Write '0' to clear */
;;;409        }
;;;410    
;;;411    }
00007e  bd70              POP      {r4-r6,pc}
                  |L2.128|
000080  f8d4016c          LDR      r0,[r4,#0x16c]        ;404
000084  2801              CMP      r0,#1                 ;404
000086  d1fa              BNE      |L2.126|
000088  a010              ADR      r0,|L2.204|
00008a  f7fffffe          BL       __2printf
00008e  2000              MOVS     r0,#0                 ;408
000090  f8c4016c          STR      r0,[r4,#0x16c]        ;408
000094  bd70              POP      {r4-r6,pc}
;;;412    
                          ENDP

000096  0000              DCW      0x0000
                  |L2.152|
000098  5258204f          DCB      "RX OK INT\n",0
00009c  4b20494e
0000a0  540a00  
0000a3  00                DCB      0
                  |L2.164|
                          DCD      0x40070000
                  |L2.168|
0000a8  5458204f          DCB      "TX OK INT\n",0
0000ac  4b20494e
0000b0  540a00  
0000b3  00                DCB      0
                  |L2.180|
0000b4  45574152          DCB      "EWARN INT\n",0
0000b8  4e20494e
0000bc  540a00  
0000bf  00                DCB      0
                  |L2.192|
0000c0  424f4646          DCB      "BOFF INT\n",0
0000c4  20494e54
0000c8  0a00    
0000ca  00                DCB      0
0000cb  00                DCB      0
                  |L2.204|
0000cc  57616b65          DCB      "Wake up\n",0
0000d0  2075700a
0000d4  00      
0000d5  00                DCB      0
0000d6  00                DCB      0
0000d7  00                DCB      0

                          AREA ||i.CAN_Init||, CODE, READONLY, ALIGN=2

                  CAN_Init PROC
;;;582    
;;;583    void CAN_Init(void)
000000  2200              MOVS     r2,#0
;;;584    {
;;;585        CAN_Open(CAN_DEVICE_PORT,  500000, CAN_NORMAL_MODE);
000002  4902              LDR      r1,|L3.12|
000004  4802              LDR      r0,|L3.16|
000006  f7ffbffe          B.W      CAN_Open
;;;586    }
;;;587    
                          ENDP

00000a  0000              DCW      0x0000
                  |L3.12|
                          DCD      0x0007a120
                  |L3.16|
                          DCD      0x400a0000

                          AREA ||i.CAN_MsgInterrupt||, CODE, READONLY, ALIGN=2

                  CAN_MsgInterrupt PROC
;;;311    
;;;312    void CAN_MsgInterrupt(CAN_T *tCAN, uint32_t u32IIDR)
000000  b510              PUSH     {r4,lr}
;;;313    {
;;;314    	uint32_t u32MsgNum = 0;
;;;315    	
;;;316    	if(u32IIDR <= 32)
000002  2920              CMP      r1,#0x20
000004  d808              BHI      |L4.24|
;;;317    	{
;;;318    		u32MsgNum = (u32IIDR-1);
;;;319    		
;;;320    		CAN_Receive(tCAN, u32MsgNum,&rrMsg);
000006  4a05              LDR      r2,|L4.28|
000008  1e49              SUBS     r1,r1,#1
00000a  f7fffffe          BL       CAN_Receive
;;;321            CAN_ShowMsg(&rrMsg);
00000e  e8bd4010          POP      {r4,lr}
000012  4802              LDR      r0,|L4.28|
000014  f7ffbffe          B.W      CAN_ShowMsg
                  |L4.24|
;;;322    		// if ((rrMsg.FrameType == CAN_DATA_FRAME))
;;;323    		// {           		
;;;324    			// CAN_ShowMsg(&rrMsg);
;;;325    			// // printf RX only
;;;326    			// if  (!( (u32MsgNum == 6) || 
;;;327    			// 	(u32MsgNum == 7) || 
;;;328    			// 	(u32MsgNum == 22) || 
;;;329    			// 	(u32MsgNum == 23) || 
;;;330    			// 	(u32MsgNum == 4) || 
;;;331    			// 	(u32MsgNum == 5) || 
;;;332    			// 	(u32MsgNum == 20) || 
;;;333    			// 	(u32MsgNum == 21) ))
;;;334    			// {
;;;335    			// 	printf("%s -Num:%2d \r\n", (tCAN == CAN0) ? "HostA" : "DeviceB"  ,u32MsgNum);		
;;;336    			// 	CAN_ShowMsg(&rrMsg);
;;;337    			// }
;;;338    		// }
;;;339    		
;;;340    		// if(rrMsg.FrameType==CAN_REMOTE_FRAME)
;;;341    		// {
;;;342    		// 	printf("\r\n(Remote)-Num:%2d ,ID:0x%04X ,%s(0x%02X) ,len:0x%02X\r\n", u32MsgNum, rrMsg.Id,rrMsg.IdType?"EXT":"STD" ,rrMsg.IdType , rrMsg.DLC );			
;;;343    		// }
;;;344    
;;;345    //		printf("\r\n");
;;;346    	}
;;;347    }
000018  bd10              POP      {r4,pc}
;;;348    
                          ENDP

00001a  0000              DCW      0x0000
                  |L4.28|
                          DCD      ||.bss||

                          AREA ||i.CAN_Setup||, CODE, READONLY, ALIGN=2

                  CAN_Setup PROC
;;;559    
;;;560    void CAN_Setup(void)
000000  b510              PUSH     {r4,lr}
;;;561    {
;;;562        DEVICE_SetRxMsg(CAN_DEVICE_PORT);
000002  4c06              LDR      r4,|L5.28|
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       DEVICE_SetRxMsg
;;;563    
;;;564        DEVICE_Tx(CAN_DEVICE_PORT);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       DEVICE_Tx
;;;565           
;;;566    	DEVICE_SetTxMsg_Remote_Frame(CAN_DEVICE_PORT);
000010  4620              MOV      r0,r4
000012  e8bd4010          POP      {r4,lr}
000016  f7ffbffe          B.W      DEVICE_SetTxMsg_Remote_Frame
;;;567    
;;;568    }
;;;569    
                          ENDP

00001a  0000              DCW      0x0000
                  |L5.28|
                          DCD      0x400a0000

                          AREA ||i.CAN_ShowMsg||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  CAN_ShowMsg PROC
;;;289    
;;;290    void CAN_ShowMsg(STR_CANMSG_T* Msg)
000000  b570              PUSH     {r4-r6,lr}
;;;291    {
000002  4605              MOV      r5,r0
;;;292        uint8_t i;
;;;293        static uint32_t cnt = 0;
;;;294    
;;;295        UART_WAIT_TX_EMPTY(UART0);	
000004  4817              LDR      r0,|L6.100|
                  |L6.6|
000006  6981              LDR      r1,[r0,#0x18]
000008  00c9              LSLS     r1,r1,#3
00000a  d5fc              BPL      |L6.6|
;;;296    	//printf("\n\n");
;;;297        printf("cnt =%d,",cnt++);
00000c  4816              LDR      r0,|L6.104|
00000e  68c1              LDR      r1,[r0,#0xc]  ; cnt
000010  1c4a              ADDS     r2,r1,#1
000012  60c2              STR      r2,[r0,#0xc]  ; cnt
000014  a015              ADR      r0,|L6.108|
000016  f7fffffe          BL       __2printf
;;;298    	printf("MsgID[0x%04X]", Msg->Id);
00001a  a017              ADR      r0,|L6.120|
00001c  68a9              LDR      r1,[r5,#8]
00001e  f7fffffe          BL       __2printf
;;;299    	printf("Type=%s(0x%02X),",Msg->IdType?"EXT":"STD" ,Msg->IdType);
000022  682a              LDR      r2,[r5,#0]
000024  b10a              CBZ      r2,|L6.42|
000026  a118              ADR      r1,|L6.136|
000028  e000              B        |L6.44|
                  |L6.42|
00002a  a118              ADR      r1,|L6.140|
                  |L6.44|
00002c  a018              ADR      r0,|L6.144|
00002e  f7fffffe          BL       __2printf
;;;300    	// printf("Frame=%s(0x%02X),", Msg->FrameType?"DATA_FRAME":"REMOTE_FRAME" , Msg->FrameType);
;;;301    	printf("length=0x%02X\r\n", Msg->DLC);
000032  7b29              LDRB     r1,[r5,#0xc]
000034  a01b              ADR      r0,|L6.164|
000036  f7fffffe          BL       __2printf
;;;302    	printf("Data is: ");
00003a  a01e              ADR      r0,|L6.180|
00003c  f7fffffe          BL       __2printf
;;;303    	for(i=0; i<Msg->DLC; i++)
000040  2400              MOVS     r4,#0
000042  e006              B        |L6.82|
                  |L6.68|
;;;304    	{
;;;305    		printf("0x%02X ,",Msg->Data[i]);
000044  1928              ADDS     r0,r5,r4
000046  7b41              LDRB     r1,[r0,#0xd]
000048  a01d              ADR      r0,|L6.192|
00004a  f7fffffe          BL       __2printf
00004e  1c64              ADDS     r4,r4,#1
000050  b2e4              UXTB     r4,r4                 ;303
                  |L6.82|
000052  7b28              LDRB     r0,[r5,#0xc]          ;303
000054  42a0              CMP      r0,r4                 ;303
000056  d8f5              BHI      |L6.68|
;;;306    	}
;;;307    	printf("\r\n");
000058  e8bd4070          POP      {r4-r6,lr}
00005c  a01b              ADR      r0,|L6.204|
00005e  f7ffbffe          B.W      __2printf
;;;308    
;;;309    }
;;;310    
                          ENDP

000062  0000              DCW      0x0000
                  |L6.100|
                          DCD      0x40070000
                  |L6.104|
                          DCD      ||.data||
                  |L6.108|
00006c  636e7420          DCB      "cnt =%d,",0
000070  3d25642c
000074  00      
000075  00                DCB      0
000076  00                DCB      0
000077  00                DCB      0
                  |L6.120|
000078  4d736749          DCB      "MsgID[0x%04X]",0
00007c  445b3078
000080  25303458
000084  5d00    
000086  00                DCB      0
000087  00                DCB      0
                  |L6.136|
000088  45585400          DCB      "EXT",0
                  |L6.140|
00008c  53544400          DCB      "STD",0
                  |L6.144|
000090  54797065          DCB      "Type=%s(0x%02X),",0
000094  3d257328
000098  30782530
00009c  3258292c
0000a0  00      
0000a1  00                DCB      0
0000a2  00                DCB      0
0000a3  00                DCB      0
                  |L6.164|
0000a4  6c656e67          DCB      "length=0x%02X\r\n",0
0000a8  74683d30
0000ac  78253032
0000b0  580d0a00
                  |L6.180|
0000b4  44617461          DCB      "Data is: ",0
0000b8  2069733a
0000bc  2000    
0000be  00                DCB      0
0000bf  00                DCB      0
                  |L6.192|
0000c0  30782530          DCB      "0x%02X ,",0
0000c4  3258202c
0000c8  00      
0000c9  00                DCB      0
0000ca  00                DCB      0
0000cb  00                DCB      0
                  |L6.204|
0000cc  0d0a00            DCB      "\r\n",0
0000cf  00                DCB      0

                          AREA ||i.DEVICE_SetRxMsg||, CODE, READONLY, ALIGN=2

                  DEVICE_SetRxMsg PROC
;;;425    
;;;426    void DEVICE_SetRxMsg(CAN_T *tCAN)
000000  b510              PUSH     {r4,lr}
;;;427    {
000002  4604              MOV      r4,r0
;;;428        if(CAN_SetRxMsg(tCAN, MSG(NORMAL_MSG_ID_ID02),CAN_STD_ID, CAN_MSG_ID02) == FALSE)
000004  f2404301          MOV      r3,#0x401
000008  2200              MOVS     r2,#0
00000a  2110              MOVS     r1,#0x10
00000c  f7fffffe          BL       CAN_SetRxMsg
000010  b320              CBZ      r0,|L7.92|
;;;429        {
;;;430            printf("Set Rx Msg Object failed\n");
;;;431            return;
;;;432        }
;;;433    
;;;434        if(CAN_SetRxMsg(tCAN, MSG(NORMAL_MSG_ID_ID03),CAN_EXT_ID, CAN_MSG_ID03) == FALSE)
000012  f24f5304          MOV      r3,#0xf504
000016  2201              MOVS     r2,#1
000018  2111              MOVS     r1,#0x11
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       CAN_SetRxMsg
000020  b1e0              CBZ      r0,|L7.92|
;;;435        {
;;;436            printf("Set Rx Msg Object failed\n");
;;;437            return;
;;;438        }
;;;439    
;;;440        if(CAN_SetRxMsg_Remote(tCAN, MSG(REMOTE_MSG_ID_ID02) ,CAN_STD_ID, CAN_MSG_REMOTE_ID02) == FALSE)
000022  f2406301          MOV      r3,#0x601
000026  2200              MOVS     r2,#0
000028  2112              MOVS     r1,#0x12
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       CAN_SetRxMsg_Remote
000030  b1a0              CBZ      r0,|L7.92|
;;;441        {
;;;442            printf("Set Rx Msg Object failed\n");
;;;443            return;
;;;444        }
;;;445    
;;;446    	if(CAN_SetRxMsg_Remote(tCAN, MSG(REMOTE_MSG_ID_ID03) ,CAN_EXT_ID, CAN_MSG_REMOTE_ID03) == FALSE)
000032  f64f23ee          MOV      r3,#0xfaee
000036  2201              MOVS     r2,#1
000038  2113              MOVS     r1,#0x13
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       CAN_SetRxMsg_Remote
000040  b160              CBZ      r0,|L7.92|
;;;447        {
;;;448            printf("Set Rx Msg Object failed\n");
;;;449            return;
;;;450        }
;;;451    
;;;452        
;;;453    	CAN_EnableInt(tCAN, CAN_CON_IE_Msk | CAN_CON_SIE_Msk);
000042  2106              MOVS     r1,#6
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       CAN_EnableInt
;;;454    
;;;455        NVIC_SetPriority(CAN0_IRQn, 0);
00004a  2100              MOVS     r1,#0
00004c  2038              MOVS     r0,#0x38
00004e  f7fffffe          BL       NVIC_SetPriority
;;;456        NVIC_EnableIRQ(CAN0_IRQn);
000052  e8bd4010          POP      {r4,lr}
000056  2038              MOVS     r0,#0x38
000058  f7ffbffe          B.W      NVIC_EnableIRQ
                  |L7.92|
00005c  e8bd4010          POP      {r4,lr}               ;448
000060  a001              ADR      r0,|L7.104|
000062  f7ffbffe          B.W      __2printf
;;;457    
;;;458        // NVIC_SetPriority(CAN1_IRQn, 0);
;;;459        // NVIC_EnableIRQ(CAN1_IRQn);
;;;460    }
;;;461    
                          ENDP

000066  0000              DCW      0x0000
                  |L7.104|
000068  53657420          DCB      "Set Rx Msg Object failed\n",0
00006c  5278204d
000070  7367204f
000074  626a6563
000078  74206661
00007c  696c6564
000080  0a00    
000082  00                DCB      0
000083  00                DCB      0

                          AREA ||i.DEVICE_SetTxMsg_Remote_Frame||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  DEVICE_SetTxMsg_Remote_Frame PROC
;;;461    
;;;462    void DEVICE_SetTxMsg_Remote_Frame(CAN_T *tCAN)
000000  b530              PUSH     {r4,r5,lr}
;;;463    {
000002  4605              MOV      r5,r0
000004  b087              SUB      sp,sp,#0x1c
;;;464        // uint8_t i = 0;
;;;465        STR_CANMSG_T tMsg;
;;;466    
;;;467        printf("%s start\r\n",__FUNCTION__);
000006  4917              LDR      r1,|L8.100|
000008  a017              ADR      r0,|L8.104|
00000a  f7fffffe          BL       __2printf
;;;468    
;;;469    	tMsg.FrameType= CAN_REMOTE_FRAME;
00000e  2400              MOVS     r4,#0
;;;470    	tMsg.IdType   = CAN_STD_ID;
;;;471    	tMsg.Id       = CAN_MSG_REMOTE_ID00;
000010  f2405001          MOV      r0,#0x501
;;;472    	tMsg.DLC      = 0;
000014  9002              STR      r0,[sp,#8]
000016  9401              STR      r4,[sp,#4]            ;470
000018  9400              STR      r4,[sp,#0]
00001a  f88d400c          STRB     r4,[sp,#0xc]
;;;473    
;;;474        // for( i = 0 ; i < tMsg.DLC ; i++)
;;;475        // {
;;;476        //     tMsg.Data[i] = i;
;;;477        // }
;;;478    
;;;479    
;;;480    	if(CAN_Transmit(tCAN, MSG(REMOTE_MSG_ID_ID00),&tMsg) == FALSE)   // Configure Msg RAM and send the Msg in the RAM
00001e  466a              MOV      r2,sp
000020  2114              MOVS     r1,#0x14
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       CAN_Transmit
000028  b1b8              CBZ      r0,|L8.90|
;;;481    	{
;;;482    		printf("Set Tx Msg Object failed\n");
;;;483    		return;
;;;484    	}
;;;485    
;;;486    	tMsg.FrameType= CAN_REMOTE_FRAME;
;;;487    	tMsg.IdType   = CAN_EXT_ID;
00002a  2001              MOVS     r0,#1
00002c  e9cd0400          STRD     r0,r4,[sp,#0]
;;;488    	tMsg.Id       = CAN_MSG_REMOTE_ID01;
000030  f64f00ee          MOV      r0,#0xf8ee
;;;489    	tMsg.DLC      = 0;
000034  9002              STR      r0,[sp,#8]
000036  f88d400c          STRB     r4,[sp,#0xc]
;;;490    
;;;491        // for( i = 0 ; i < tMsg.DLC ; i++)
;;;492        // {
;;;493        //     tMsg.Data[i] = 0x70+i;
;;;494        // }
;;;495    
;;;496    	if(CAN_Transmit(tCAN, MSG(REMOTE_MSG_ID_ID01),&tMsg) == FALSE)   // Configure Msg RAM and send the Msg in the RAM
00003a  466a              MOV      r2,sp
00003c  2115              MOVS     r1,#0x15
00003e  4628              MOV      r0,r5
000040  f7fffffe          BL       CAN_Transmit
000044  b148              CBZ      r0,|L8.90|
;;;497    	{
;;;498    		printf("Set Tx Msg Object failed\n");
;;;499    		return;
;;;500    	}	
;;;501    
;;;502        // UART_WAIT_TX_EMPTY(UART0);    
;;;503        while(!UART_IS_TX_EMPTY(UART0));
000046  480b              LDR      r0,|L8.116|
                  |L8.72|
000048  6981              LDR      r1,[r0,#0x18]
00004a  00c9              LSLS     r1,r1,#3
00004c  d5fc              BPL      |L8.72|
;;;504        printf("%s end\r\n",__FUNCTION__);  
00004e  4905              LDR      r1,|L8.100|
000050  a009              ADR      r0,|L8.120|
000052  f7fffffe          BL       __2printf
                  |L8.86|
;;;505    	
;;;506    }
000056  b007              ADD      sp,sp,#0x1c
000058  bd30              POP      {r4,r5,pc}
                  |L8.90|
00005a  a00a              ADR      r0,|L8.132|
00005c  f7fffffe          BL       __2printf
000060  e7f9              B        |L8.86|
;;;507    
                          ENDP

000062  0000              DCW      0x0000
                  |L8.100|
                          DCD      ||.constdata||
                  |L8.104|
000068  25732073          DCB      "%s start\r\n",0
00006c  74617274
000070  0d0a00  
000073  00                DCB      0
                  |L8.116|
                          DCD      0x40070000
                  |L8.120|
000078  25732065          DCB      "%s end\r\n",0
00007c  6e640d0a
000080  00      
000081  00                DCB      0
000082  00                DCB      0
000083  00                DCB      0
                  |L8.132|
000084  53657420          DCB      "Set Tx Msg Object failed\n",0
000088  5478204d
00008c  7367204f
000090  626a6563
000094  74206661
000098  696c6564
00009c  0a00    
00009e  00                DCB      0
00009f  00                DCB      0

                          AREA ||i.DEVICE_Tx||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_str
                  DEVICE_Tx PROC
;;;507    
;;;508    void DEVICE_Tx(CAN_T *tCAN)
000000  b570              PUSH     {r4-r6,lr}
;;;509    {
000002  4605              MOV      r5,r0
;;;510        STR_CANMSG_T tMsg;
;;;511        uint32_t i;
;;;512    	const uint8_t can_data_00[5] = {0x30 , 0x31 , 0x32 , 0x33 , 0x34};
000004  a02d              ADR      r0,|L9.188|
000006  b088              SUB      sp,sp,#0x20           ;509
000008  e9d01000          LDRD     r1,r0,[r0,#0]
00000c  e9cd1006          STRD     r1,r0,[sp,#0x18]
;;;513    
;;;514        static uint8_t cnt = 0;
;;;515    
;;;516        printf("%s start\r\n",__FUNCTION__);
000010  492c              LDR      r1,|L9.196|
000012  a02d              ADR      r0,|L9.200|
000014  f7fffffe          BL       __2printf
;;;517    	
;;;518        /* Send a 11-bits message */
;;;519        tMsg.FrameType= CAN_DATA_FRAME;
000018  2601              MOVS     r6,#1
;;;520        tMsg.IdType   = CAN_STD_ID;
00001a  2000              MOVS     r0,#0
00001c  e9cd0600          STRD     r0,r6,[sp,#0]
;;;521        tMsg.Id       = CAN_MSG_ID00;
000020  f2403001          MOV      r0,#0x301
;;;522        tMsg.DLC      = strlen((char*) can_data_00);	//SIZEOF(can_data_00);	//2;
000024  9002              STR      r0,[sp,#8]
000026  a806              ADD      r0,sp,#0x18
000028  f7fffffe          BL       strlen
00002c  f88d000c          STRB     r0,[sp,#0xc]
;;;523    	for ( i = 0 ; i < 5 ; i++)
000030  2100              MOVS     r1,#0
000032  a806              ADD      r0,sp,#0x18           ;512
000034  466c              MOV      r4,sp                 ;510
                  |L9.54|
;;;524    	{
;;;525    		tMsg.Data[i]  = can_data_00[i];
000036  5c42              LDRB     r2,[r0,r1]
000038  1863              ADDS     r3,r4,r1
00003a  1c49              ADDS     r1,r1,#1
00003c  735a              STRB     r2,[r3,#0xd]
00003e  2905              CMP      r1,#5                 ;523
000040  d3f9              BCC      |L9.54|
;;;526    	}
;;;527        tMsg.Data[4] +=  tMsg.Data[4];
000042  f89d0011          LDRB     r0,[sp,#0x11]
;;;528    
;;;529        if(CAN_Transmit(tCAN, MSG(NORMAL_MSG_ID_ID00),&tMsg) == FALSE) 
000046  4622              MOV      r2,r4
000048  0040              LSLS     r0,r0,#1              ;527
00004a  f88d0011          STRB     r0,[sp,#0x11]         ;527
00004e  2116              MOVS     r1,#0x16
000050  4628              MOV      r0,r5
000052  f7fffffe          BL       CAN_Transmit
000056  b368              CBZ      r0,|L9.180|
;;;530        {
;;;531            printf("Set Tx Msg Object failed\n");
;;;532            return;
;;;533        }
;;;534    
;;;535        /* Send a 29-bits message */
;;;536        tMsg.FrameType= CAN_DATA_FRAME;
;;;537        tMsg.IdType   = CAN_EXT_ID;
;;;538        tMsg.Id       = CAN_MSG_ID01;
000058  f24f5002          MOV      r0,#0xf502
;;;539        tMsg.DLC      = 8;
00005c  9002              STR      r0,[sp,#8]
00005e  2008              MOVS     r0,#8
000060  9601              STR      r6,[sp,#4]            ;537
000062  9600              STR      r6,[sp,#0]
000064  f88d000c          STRB     r0,[sp,#0xc]
;;;540    	for ( i = 0 ; i < 8 ; i++)
000068  2100              MOVS     r1,#0
                  |L9.106|
;;;541    	{
;;;542    		tMsg.Data[i]  = 0x70+i;
00006a  f1010070          ADD      r0,r1,#0x70
00006e  1862              ADDS     r2,r4,r1
000070  1c49              ADDS     r1,r1,#1
000072  7350              STRB     r0,[r2,#0xd]
000074  2908              CMP      r1,#8                 ;540
000076  d3f8              BCC      |L9.106|
;;;543    	}
;;;544        tMsg.Data[7] +=  cnt;
000078  4c16              LDR      r4,|L9.212|
00007a  f89d0014          LDRB     r0,[sp,#0x14]
00007e  7821              LDRB     r1,[r4,#0]  ; cnt
000080  4408              ADD      r0,r0,r1
000082  b2c1              UXTB     r1,r0
000084  f88d1014          STRB     r1,[sp,#0x14]
;;;545        printf("hex:0x%02X\r\n",tMsg.Data[7]);
000088  a013              ADR      r0,|L9.216|
00008a  f7fffffe          BL       __2printf
;;;546    
;;;547        if(CAN_Transmit(tCAN, MSG(NORMAL_MSG_ID_ID01),&tMsg) == FALSE)
00008e  466a              MOV      r2,sp
000090  2117              MOVS     r1,#0x17
000092  4628              MOV      r0,r5
000094  f7fffffe          BL       CAN_Transmit
000098  b160              CBZ      r0,|L9.180|
;;;548        {
;;;549            printf("Set Tx Msg Object failed\n");
;;;550            return;
;;;551        }
;;;552        
;;;553        // UART_WAIT_TX_EMPTY(UART0);	
;;;554        while(!UART_IS_TX_EMPTY(UART0));
00009a  4813              LDR      r0,|L9.232|
                  |L9.156|
00009c  6981              LDR      r1,[r0,#0x18]
00009e  00c9              LSLS     r1,r1,#3
0000a0  d5fc              BPL      |L9.156|
;;;555        printf("%s end\r\n",__FUNCTION__);   
0000a2  4908              LDR      r1,|L9.196|
0000a4  a011              ADR      r0,|L9.236|
0000a6  f7fffffe          BL       __2printf
;;;556        cnt++;
0000aa  7820              LDRB     r0,[r4,#0]  ; cnt
0000ac  1c40              ADDS     r0,r0,#1
0000ae  7020              STRB     r0,[r4,#0]
                  |L9.176|
;;;557    }
0000b0  b008              ADD      sp,sp,#0x20
0000b2  bd70              POP      {r4-r6,pc}
                  |L9.180|
0000b4  a010              ADR      r0,|L9.248|
0000b6  f7fffffe          BL       __2printf
0000ba  e7f9              B        |L9.176|
;;;558    
                          ENDP

                  |L9.188|
0000bc  30313233          DCB      "01234",0
0000c0  3400    
0000c2  00                DCB      0
0000c3  00                DCB      0
                  |L9.196|
                          DCD      ||.constdata||+0x1d
                  |L9.200|
0000c8  25732073          DCB      "%s start\r\n",0
0000cc  74617274
0000d0  0d0a00  
0000d3  00                DCB      0
                  |L9.212|
                          DCD      ||.data||
                  |L9.216|
0000d8  6865783a          DCB      "hex:0x%02X\r\n",0
0000dc  30782530
0000e0  32580d0a
0000e4  00      
0000e5  00                DCB      0
0000e6  00                DCB      0
0000e7  00                DCB      0
                  |L9.232|
                          DCD      0x40070000
                  |L9.236|
0000ec  25732065          DCB      "%s end\r\n",0
0000f0  6e640d0a
0000f4  00      
0000f5  00                DCB      0
0000f6  00                DCB      0
0000f7  00                DCB      0
                  |L9.248|
0000f8  53657420          DCB      "Set Tx Msg Object failed\n",0
0000fc  5478204d
000100  7367204f
000104  626a6563
000108  74206661
00010c  696c6564
000110  0a00    
000112  00                DCB      0
000113  00                DCB      0

                          AREA ||i.GPIO_Init||, CODE, READONLY, ALIGN=2

                  GPIO_Init PROC
;;;739    
;;;740    void GPIO_Init(void)
000000  b510              PUSH     {r4,lr}
;;;741    {
;;;742    	SYS->GPH_MFPL = (SYS->GPH_MFPL & ~(SYS_GPH_MFPL_PH0MFP_Msk)) | (SYS_GPH_MFPL_PH0MFP_GPIO);
000002  f04f4080          MOV      r0,#0x40000000
000006  6e81              LDR      r1,[r0,#0x68]
000008  f021010f          BIC      r1,r1,#0xf
00000c  6681              STR      r1,[r0,#0x68]
;;;743    	SYS->GPH_MFPL = (SYS->GPH_MFPL & ~(SYS_GPH_MFPL_PH1MFP_Msk)) | (SYS_GPH_MFPL_PH1MFP_GPIO);
00000e  6e81              LDR      r1,[r0,#0x68]
000010  f02101f0          BIC      r1,r1,#0xf0
000014  6681              STR      r1,[r0,#0x68]
;;;744    	SYS->GPH_MFPL = (SYS->GPH_MFPL & ~(SYS_GPH_MFPL_PH2MFP_Msk)) | (SYS_GPH_MFPL_PH2MFP_GPIO);
000016  6e81              LDR      r1,[r0,#0x68]
000018  f4216170          BIC      r1,r1,#0xf00
00001c  6681              STR      r1,[r0,#0x68]
;;;745    
;;;746    	//EVM LED
;;;747    	GPIO_SetMode(PH,BIT0,GPIO_MODE_OUTPUT);
00001e  4c09              LDR      r4,|L10.68|
000020  2201              MOVS     r2,#1
000022  4611              MOV      r1,r2
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       GPIO_SetMode
;;;748    	GPIO_SetMode(PH,BIT1,GPIO_MODE_OUTPUT);
00002a  2201              MOVS     r2,#1
00002c  2102              MOVS     r1,#2
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       GPIO_SetMode
;;;749    	GPIO_SetMode(PH,BIT2,GPIO_MODE_OUTPUT);
000034  4620              MOV      r0,r4
000036  2201              MOVS     r2,#1
000038  e8bd4010          POP      {r4,lr}
00003c  2104              MOVS     r1,#4
00003e  f7ffbffe          B.W      GPIO_SetMode
;;;750    	
;;;751    }
;;;752    
                          ENDP

000042  0000              DCW      0x0000
                  |L10.68|
                          DCD      0x400041c0

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_EnableIRQ PROC
;;;1625    */
;;;1626   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1627   {
;;;1628     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0940              LSRS     r0,r0,#5
00000a  0080              LSLS     r0,r0,#2
00000c  f10020e0          ADD      r0,r0,#0xe000e000
000010  f8c01100          STR      r1,[r0,#0x100]
;;;1629   }
000014  4770              BX       lr
;;;1630   
                          ENDP


                          AREA ||i.NVIC_SetPriority||, CODE, READONLY, ALIGN=1

                  NVIC_SetPriority PROC
;;;1697    */
;;;1698   __STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
000000  0709              LSLS     r1,r1,#28
;;;1699   {
;;;1700     if ((int32_t)(IRQn) < 0)
;;;1701     {
;;;1702       SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
000002  0e09              LSRS     r1,r1,#24
000004  2800              CMP      r0,#0                 ;1700
000006  da06              BGE      |L12.22|
000008  f000000f          AND      r0,r0,#0xf
00000c  f10020e0          ADD      r0,r0,#0xe000e000
000010  f8801d14          STRB     r1,[r0,#0xd14]
;;;1703     }
;;;1704     else
;;;1705     {
;;;1706       NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
;;;1707     }
;;;1708   }
000014  4770              BX       lr
                  |L12.22|
000016  f10020e0          ADD      r0,r0,#0xe000e000
00001a  f8801400          STRB     r1,[r0,#0x400]        ;1706
00001e  4770              BX       lr
;;;1709   
                          ENDP


                          AREA ||i.RS_PIN_Init||, CODE, READONLY, ALIGN=2

                  RS_PIN_Init PROC
;;;569    
;;;570    void RS_PIN_Init(void)   // CAN transceiver RS pin , pull low
000000  490e              LDR      r1,|L13.60|
;;;571    {
000002  b510              PUSH     {r4,lr}
;;;572    	PA2 = 0;
000004  2000              MOVS     r0,#0
000006  6008              STR      r0,[r1,#0]
;;;573    	PA3 = 0;
000008  1d09              ADDS     r1,r1,#4
00000a  6008              STR      r0,[r1,#0]
;;;574    
;;;575    	SYS->GPA_MFPL = (SYS->GPA_MFPL & ~(SYS_GPA_MFPL_PA2MFP_Msk)) | (SYS_GPA_MFPL_PA2MFP_GPIO);
00000c  f04f4080          MOV      r0,#0x40000000
000010  6b01              LDR      r1,[r0,#0x30]
000012  f4216170          BIC      r1,r1,#0xf00
000016  6301              STR      r1,[r0,#0x30]
;;;576    	SYS->GPA_MFPL = (SYS->GPA_MFPL & ~(SYS_GPA_MFPL_PA3MFP_Msk)) | (SYS_GPA_MFPL_PA3MFP_GPIO);
000018  6b01              LDR      r1,[r0,#0x30]
00001a  f4214170          BIC      r1,r1,#0xf000
00001e  6301              STR      r1,[r0,#0x30]
;;;577    
;;;578    	GPIO_SetMode(PA,BIT2,GPIO_MODE_OUTPUT);
000020  f04f2440          MOV      r4,#0x40004000
000024  2201              MOVS     r2,#1
000026  2104              MOVS     r1,#4
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       GPIO_SetMode
;;;579    	GPIO_SetMode(PA,BIT3,GPIO_MODE_OUTPUT);
00002e  4620              MOV      r0,r4
000030  2201              MOVS     r2,#1
000032  e8bd4010          POP      {r4,lr}
000036  2108              MOVS     r1,#8
000038  f7ffbffe          B.W      GPIO_SetMode
;;;580    	
;;;581    }
;;;582    
                          ENDP

                  |L13.60|
                          DCD      0x40004808

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;752    
;;;753    void SYS_Init(void)
000000  b570              PUSH     {r4-r6,lr}
;;;754    {
;;;755        /* Unlock protected registers */
;;;756        SYS_UnlockReg();
000002  f7fffffe          BL       SYS_UnlockReg
;;;757    
;;;758        /* Set XT1_OUT(PF.2) and XT1_IN(PF.3) to input mode */
;;;759        PF->MODE &= ~(GPIO_MODE_MODE2_Msk | GPIO_MODE_MODE3_Msk);
000006  f04f2040          MOV      r0,#0x40004000
00000a  f8d01140          LDR      r1,[r0,#0x140]
00000e  f02101f0          BIC      r1,r1,#0xf0
000012  f8c01140          STR      r1,[r0,#0x140]
;;;760    
;;;761        CLK_EnableXtalRC(CLK_PWRCTL_HIRCEN_Msk);
000016  2004              MOVS     r0,#4
000018  f7fffffe          BL       CLK_EnableXtalRC
;;;762        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00001c  2010              MOVS     r0,#0x10
00001e  f7fffffe          BL       CLK_WaitClockReady
;;;763    
;;;764        CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);
000022  2001              MOVS     r0,#1
000024  f7fffffe          BL       CLK_EnableXtalRC
;;;765        CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
000028  2001              MOVS     r0,#1
00002a  f7fffffe          BL       CLK_WaitClockReady
;;;766    
;;;767    //    CLK_EnableXtalRC(CLK_PWRCTL_LIRCEN_Msk);
;;;768    //    CLK_WaitClockReady(CLK_STATUS_LIRCSTB_Msk);
;;;769    
;;;770    //    CLK_EnableXtalRC(CLK_PWRCTL_LXTEN_Msk);
;;;771    //    CLK_WaitClockReady(CLK_STATUS_LXTSTB_Msk);
;;;772    
;;;773        /* Set core clock as PLL_CLOCK from PLL */
;;;774        CLK_SetCoreClock(FREQ_192MHZ);
00002e  4819              LDR      r0,|L14.148|
000030  f7fffffe          BL       CLK_SetCoreClock
;;;775        /* Set PCLK0/PCLK1 to HCLK/2 */
;;;776        CLK->PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV2 | CLK_PCLKDIV_APB1DIV_DIV2);
000034  2011              MOVS     r0,#0x11
000036  0784              LSLS     r4,r0,#30
000038  f8c40234          STR      r0,[r4,#0x234]
;;;777    
;;;778        /* Enable UART clock */
;;;779        CLK_EnableModuleClock(UART0_MODULE);
00003c  4d16              LDR      r5,|L14.152|
00003e  4628              MOV      r0,r5
000040  f7fffffe          BL       CLK_EnableModuleClock
;;;780        /* Select UART clock source from HXT */
;;;781        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HIRC, CLK_CLKDIV0_UART0(1));
000044  2200              MOVS     r2,#0
000046  f04f7140          MOV      r1,#0x3000000
00004a  4628              MOV      r0,r5
00004c  f7fffffe          BL       CLK_SetModuleClock
;;;782    
;;;783        /* Set GPB multi-function pins for UART0 RXD and TXD */
;;;784        SYS->GPB_MFPH &= ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk);
000050  6be0              LDR      r0,[r4,#0x3c]
000052  f420007f          BIC      r0,r0,#0xff0000
000056  63e0              STR      r0,[r4,#0x3c]
;;;785        SYS->GPB_MFPH |= (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
000058  6be0              LDR      r0,[r4,#0x3c]
00005a  f44000cc          ORR      r0,r0,#0x660000
00005e  63e0              STR      r0,[r4,#0x3c]
;;;786    
;;;787        CLK_EnableModuleClock(TMR1_MODULE);
000060  4d0e              LDR      r5,|L14.156|
000062  4628              MOV      r0,r5
000064  f7fffffe          BL       CLK_EnableModuleClock
;;;788        CLK_SetModuleClock(TMR1_MODULE, CLK_CLKSEL1_TMR1SEL_HIRC, 0);
000068  2200              MOVS     r2,#0
00006a  f44f41e0          MOV      r1,#0x7000
00006e  4628              MOV      r0,r5
000070  f7fffffe          BL       CLK_SetModuleClock
;;;789    
;;;790        CLK_EnableModuleClock(CAN0_MODULE);
000074  480a              LDR      r0,|L14.160|
000076  f7fffffe          BL       CLK_EnableModuleClock
;;;791        // CLK_EnableModuleClock(CAN1_MODULE);
;;;792    
;;;793        /* Set PA multi-function pins for CAN0 RXD(PA.4) and TXD(PA.5) */
;;;794        SYS->GPA_MFPL = (SYS->GPA_MFPL & ~(SYS_GPA_MFPL_PA4MFP_Msk | SYS_GPA_MFPL_PA5MFP_Msk)) |
00007a  6b20              LDR      r0,[r4,#0x30]
00007c  f420007f          BIC      r0,r0,#0xff0000
000080  f440002a          ORR      r0,r0,#0xaa0000
000084  6320              STR      r0,[r4,#0x30]
;;;795                        (SYS_GPA_MFPL_PA4MFP_CAN0_RXD | SYS_GPA_MFPL_PA5MFP_CAN0_TXD);
;;;796    
;;;797        // /* Set PE multi-function pins for CAN1 TXD(PE.7) and RXD(PE.6) */
;;;798        // SYS->GPB_MFPL = (SYS->GPB_MFPL & ~(SYS_GPB_MFPL_PB6MFP_Msk | SYS_GPB_MFPL_PB7MFP_Msk)) |
;;;799        //                 (SYS_GPB_MFPL_PB6MFP_CAN1_RXD | SYS_GPB_MFPL_PB7MFP_CAN1_TXD);
;;;800    
;;;801    	
;;;802        /* Update System Core Clock */
;;;803        /* User can use SystemCoreClockUpdate() to calculate SystemCoreClock. */
;;;804        SystemCoreClockUpdate();
000086  f7fffffe          BL       SystemCoreClockUpdate
00008a  2000              MOVS     r0,#0
00008c  f8c40100          STR      r0,[r4,#0x100]
;;;805    
;;;806        /* Lock protected registers */
;;;807        SYS_LockReg();
;;;808    }
000090  bd70              POP      {r4-r6,pc}
;;;809    
                          ENDP

000092  0000              DCW      0x0000
                  |L14.148|
                          DCD      0x0b71b000
                  |L14.152|
                          DCD      0x57803d10
                  |L14.156|
                          DCD      0x5ec00003
                  |L14.160|
                          DCD      0x40000018

                          AREA ||i.SYS_UnlockReg||, CODE, READONLY, ALIGN=1

                  SYS_UnlockReg PROC
;;;1585     */
;;;1586   __STATIC_INLINE void SYS_UnlockReg(void)
000000  2159              MOVS     r1,#0x59
;;;1587   {
000002  b510              PUSH     {r4,lr}
;;;1588       do
;;;1589       {
;;;1590           SYS->REGLCTL = 0x59UL;
000004  0788              LSLS     r0,r1,#30
;;;1591           SYS->REGLCTL = 0x16UL;
000006  2216              MOVS     r2,#0x16
;;;1592           SYS->REGLCTL = 0x88UL;
000008  2388              MOVS     r3,#0x88
                  |L15.10|
00000a  f8c01100          STR      r1,[r0,#0x100]        ;1590
00000e  f8c02100          STR      r2,[r0,#0x100]        ;1591
000012  f8c03100          STR      r3,[r0,#0x100]
;;;1593       }
;;;1594       while(SYS->REGLCTL == 0UL);
000016  f8d04100          LDR      r4,[r0,#0x100]
00001a  2c00              CMP      r4,#0
00001c  d0f5              BEQ      |L15.10|
;;;1595   }
00001e  bd10              POP      {r4,pc}
;;;1596   
                          ENDP


                          AREA ||i.SysTick_Handler||, CODE, READONLY, ALIGN=2

                  SysTick_Handler PROC
;;;76     
;;;77     void SysTick_Handler(void)
000000  b500              PUSH     {lr}
;;;78     {
;;;79     
;;;80         systick_counter();
000002  f7fffffe          BL       systick_counter
000006  4903              LDR      r1,|L16.20|
000008  6848              LDR      r0,[r1,#4]  ; counter_systick
00000a  1c40              ADDS     r0,r0,#1
;;;81     
;;;82         if (get_systick() >= 0xFFFFFFFF)
00000c  d100              BNE      |L16.16|
00000e  6048              STR      r0,[r1,#4]  ; counter_systick
                  |L16.16|
;;;83         {
;;;84             set_systick(0);      
;;;85         }
;;;86     
;;;87         // if ((get_systick() % 1000) == 0)
;;;88         // {
;;;89            
;;;90         // }
;;;91     
;;;92         #if defined (ENABLE_TICK_EVENT)
;;;93         TickCheckTickEvent();
;;;94         #endif    
;;;95     }
000010  bd00              POP      {pc}
;;;96     
                          ENDP

000012  0000              DCW      0x0000
                  |L16.20|
                          DCD      ||.data||

                          AREA ||i.SysTick_delay||, CODE, READONLY, ALIGN=2

                  SysTick_delay PROC
;;;96     
;;;97     void SysTick_delay(unsigned int delay)
000000  4903              LDR      r1,|L17.16|
000002  684a              LDR      r2,[r1,#4]  ; counter_systick
                  |L17.4|
000004  684b              LDR      r3,[r1,#4]  ; counter_systick
;;;98     {  
;;;99         
;;;100        unsigned int tickstart = get_systick(); 
;;;101        unsigned int wait = delay; 
;;;102    
;;;103        while((get_systick() - tickstart) < wait) 
000006  1a9b              SUBS     r3,r3,r2
000008  4283              CMP      r3,r0
00000a  d3fb              BCC      |L17.4|
;;;104        { 
;;;105        } 
;;;106    
;;;107    }
00000c  4770              BX       lr
;;;108    
                          ENDP

00000e  0000              DCW      0x0000
                  |L17.16|
                          DCD      ||.data||

                          AREA ||i.SysTick_enable||, CODE, READONLY, ALIGN=2

                  SysTick_enable PROC
;;;108    
;;;109    void SysTick_enable(unsigned int ticks_per_second)
000000  4a0d              LDR      r2,|L18.56|
;;;110    {
000002  b510              PUSH     {r4,lr}
;;;111        set_systick(0);
000004  2100              MOVS     r1,#0
000006  6051              STR      r1,[r2,#4]  ; counter_systick
;;;112        if (SysTick_Config(SystemCoreClock / ticks_per_second))
000008  490c              LDR      r1,|L18.60|
00000a  6809              LDR      r1,[r1,#0]  ; SystemCoreClock
00000c  fbb1f0f0          UDIV     r0,r1,r0
000010  1e40              SUBS     r0,r0,#1
000012  f1b07f80          CMP      r0,#0x1000000
000016  d303              BCC      |L18.32|
;;;113        {
;;;114            /* Setup SysTick Timer for 1 second interrupts  */
;;;115            printf("Set system tick error!!\n");
000018  a009              ADR      r0,|L18.64|
00001a  f7fffffe          BL       __2printf
                  |L18.30|
;;;116            while (1);
00001e  e7fe              B        |L18.30|
                  |L18.32|
000020  f04f24e0          MOV      r4,#0xe000e000
000024  6160              STR      r0,[r4,#0x14]
000026  210f              MOVS     r1,#0xf
000028  1760              ASRS     r0,r4,#29
00002a  f7fffffe          BL       NVIC_SetPriority
00002e  2000              MOVS     r0,#0
000030  61a0              STR      r0,[r4,#0x18]
000032  2007              MOVS     r0,#7
000034  6120              STR      r0,[r4,#0x10]
;;;117        }
;;;118    
;;;119        #if defined (ENABLE_TICK_EVENT)
;;;120        TickInitTickEvent();
;;;121        #endif
;;;122    }
000036  bd10              POP      {r4,pc}
;;;123    
                          ENDP

                  |L18.56|
                          DCD      ||.data||
                  |L18.60|
                          DCD      SystemCoreClock
                  |L18.64|
000040  53657420          DCB      "Set system tick error!!\n",0
000044  73797374
000048  656d2074
00004c  69636b20
000050  6572726f
000054  7221210a
000058  00      
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0

                          AREA ||i.TIMER1_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_Init PROC
;;;607    
;;;608    void TIMER1_Init(void)
000000  b510              PUSH     {r4,lr}
;;;609    {
;;;610        TIMER_Open(TIMER1, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L19.44|
000004  f44f727a          MOV      r2,#0x3e8
000008  f04f6100          MOV      r1,#0x8000000
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  f0405000          ORR      r0,r0,#0x20000000
000018  6020              STR      r0,[r4,#0]
;;;611        TIMER_EnableInt(TIMER1);
;;;612        NVIC_EnableIRQ(TMR1_IRQn);	
00001a  2021              MOVS     r0,#0x21
00001c  f7fffffe          BL       NVIC_EnableIRQ
000020  6820              LDR      r0,[r4,#0]
000022  f0404080          ORR      r0,r0,#0x40000000
000026  6020              STR      r0,[r4,#0]
;;;613        TIMER_Start(TIMER1);
;;;614    }
000028  bd10              POP      {r4,pc}
;;;615    
                          ENDP

00002a  0000              DCW      0x0000
                  |L19.44|
                          DCD      0x40050100

                          AREA ||i.TMR1_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR1_IRQHandler PROC
;;;587    
;;;588    void TMR1_IRQHandler(void)
000000  480d              LDR      r0,|L20.56|
;;;589    {
000002  b500              PUSH     {lr}
000004  6881              LDR      r1,[r0,#8]
000006  f3c10100          UBFX     r1,r1,#0,#1
00000a  2900              CMP      r1,#0
00000c  d013              BEQ      |L20.54|
00000e  2101              MOVS     r1,#1
000010  6081              STR      r1,[r0,#8]
;;;590    	
;;;591        if(TIMER_GetIntFlag(TIMER1) == 1)
;;;592        {
;;;593            TIMER_ClearIntFlag(TIMER1);
;;;594    		tick_counter();
000012  f7fffffe          BL       tick_counter
000016  4a09              LDR      r2,|L20.60|
000018  6890              LDR      r0,[r2,#8]  ; counter_tick
;;;595    
;;;596    		if ((get_tick() % 1000) == 0)
00001a  f44f717a          MOV      r1,#0x3e8
00001e  fbb0f3f1          UDIV     r3,r0,r1
000022  fb010013          MLS      r0,r1,r3,r0
000026  b928              CBNZ     r0,|L20.52|
;;;597    		{
;;;598                FLAG_PROJ_TIMER_PERIOD_1000MS = 1;//set_flag(flag_timer_period_1000ms ,ENABLE);
000028  f1020010          ADD      r0,r2,#0x10
00002c  6801              LDR      r1,[r0,#0]  ; flag_PROJ_CTL
00002e  f0410101          ORR      r1,r1,#1
000032  6001              STR      r1,[r0,#0]  ; flag_PROJ_CTL
                  |L20.52|
000034  6890              LDR      r0,[r2,#8]  ; counter_tick
                  |L20.54|
;;;599    		}
;;;600    
;;;601    		if ((get_tick() % 50) == 0)
;;;602    		{
;;;603    
;;;604    		}	
;;;605        }
;;;606    }
000036  bd00              POP      {pc}
;;;607    
                          ENDP

                  |L20.56|
                          DCD      0x40050100
                  |L20.60|
                          DCD      ||.data||

                          AREA ||i.UART0_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART0_IRQHandler PROC
;;;679    
;;;680    void UART0_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;681    {
;;;682        if(UART_GET_INT_FLAG(UART0, UART_INTSTS_RDAINT_Msk | UART_INTSTS_RXTOINT_Msk))     /* UART receive data available flag */
000002  4c0b              LDR      r4,|L21.48|
000004  69e0              LDR      r0,[r4,#0x1c]
000006  f4105f88          TST      r0,#0x1100
00000a  d102              BNE      |L21.18|
00000c  e004              B        |L21.24|
                  |L21.14|
;;;683        {
;;;684            while(UART_GET_RX_EMPTY(UART0) == 0)
;;;685            {
;;;686    			UARTx_Process();
00000e  f7fffffe          BL       UARTx_Process
                  |L21.18|
000012  69a1              LDR      r1,[r4,#0x18]         ;684
000014  0449              LSLS     r1,r1,#17             ;684
000016  d5fa              BPL      |L21.14|
                  |L21.24|
;;;687            }
;;;688        }
;;;689    
;;;690        if(UART0->FIFOSTS & (UART_FIFOSTS_BIF_Msk | UART_FIFOSTS_FEF_Msk | UART_FIFOSTS_PEF_Msk | UART_FIFOSTS_RXOVIF_Msk))
000018  69a1              LDR      r1,[r4,#0x18]
00001a  4620              MOV      r0,r4
00001c  f0110f71          TST      r1,#0x71
000020  d005              BEQ      |L21.46|
;;;691        {
;;;692            UART_ClearIntFlag(UART0, (UART_INTSTS_RLSINT_Msk| UART_INTSTS_BUFERRINT_Msk));
000022  e8bd4010          POP      {r4,lr}
000026  f44f5110          MOV      r1,#0x2400
00002a  f7ffbffe          B.W      UART_ClearIntFlag
                  |L21.46|
;;;693        }	
;;;694    }
00002e  bd10              POP      {r4,pc}
;;;695    
                          ENDP

                  |L21.48|
                          DCD      0x40070000

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART0_Init PROC
;;;695    
;;;696    void UART0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;697    {
;;;698        SYS_ResetModule(UART0_RST);
000002  4824              LDR      r0,|L22.148|
000004  f7fffffe          BL       SYS_ResetModule
;;;699    
;;;700        /* Configure UART0 and set UART0 baud rate */
;;;701        UART_Open(UART0, 115200);
000008  4c23              LDR      r4,|L22.152|
00000a  f44f31e1          MOV      r1,#0x1c200
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       UART_Open
;;;702    
;;;703    	/* Set UART receive time-out */
;;;704    	UART_SetTimeoutCnt(UART0, 20);
000014  2114              MOVS     r1,#0x14
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       UART_SetTimeoutCnt
;;;705    
;;;706    	UART0->FIFO &= ~UART_FIFO_RFITL_4BYTES;
00001c  68a0              LDR      r0,[r4,#8]
00001e  f0200010          BIC      r0,r0,#0x10
000022  60a0              STR      r0,[r4,#8]
;;;707    	UART0->FIFO |= UART_FIFO_RFITL_8BYTES;
000024  68a0              LDR      r0,[r4,#8]
000026  f0400020          ORR      r0,r0,#0x20
00002a  60a0              STR      r0,[r4,#8]
;;;708    
;;;709    	/* Enable UART Interrupt - */
;;;710    	UART_ENABLE_INT(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_TOCNTEN_Msk | UART_INTEN_RXTOIEN_Msk);
00002c  6860              LDR      r0,[r4,#4]
00002e  f6400111          MOV      r1,#0x811
000032  4308              ORRS     r0,r0,r1
000034  6060              STR      r0,[r4,#4]
;;;711    	
;;;712    	NVIC_EnableIRQ(UART0_IRQn);
000036  2024              MOVS     r0,#0x24
000038  f7fffffe          BL       NVIC_EnableIRQ
;;;713    
;;;714    	#if (_debug_log_UART_ == 1)	//debug
;;;715    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
00003c  f7fffffe          BL       CLK_GetCPUFreq
000040  4601              MOV      r1,r0
000042  a016              ADR      r0,|L22.156|
000044  f7fffffe          BL       __2printf
;;;716    	printf("CLK_GetHCLKFreq : %8d\r\n",CLK_GetHCLKFreq());
000048  f7fffffe          BL       CLK_GetHCLKFreq
00004c  4601              MOV      r1,r0
00004e  a01a              ADR      r0,|L22.184|
000050  f7fffffe          BL       __2printf
;;;717    	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
000054  f7fffffe          BL       CLK_GetHXTFreq
000058  4601              MOV      r1,r0
00005a  a01d              ADR      r0,|L22.208|
00005c  f7fffffe          BL       __2printf
;;;718    	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
000060  f7fffffe          BL       CLK_GetLXTFreq
000064  4601              MOV      r1,r0
000066  a020              ADR      r0,|L22.232|
000068  f7fffffe          BL       __2printf
;;;719    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
00006c  f7fffffe          BL       CLK_GetPCLK0Freq
000070  4601              MOV      r1,r0
000072  a023              ADR      r0,|L22.256|
000074  f7fffffe          BL       __2printf
;;;720    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());
000078  f7fffffe          BL       CLK_GetPCLK1Freq
00007c  4601              MOV      r1,r0
00007e  a027              ADR      r0,|L22.284|
000080  f7fffffe          BL       __2printf
;;;721    	printf("CLK_GetHCLKFreq : %8d\r\n",CLK_GetHCLKFreq());    	
000084  f7fffffe          BL       CLK_GetHCLKFreq
000088  4601              MOV      r1,r0
00008a  e8bd4010          POP      {r4,lr}
00008e  a00a              ADR      r0,|L22.184|
000090  f7ffbffe          B.W      __2printf
;;;722    
;;;723    //    printf("Product ID 0x%8X\n", SYS->PDID);
;;;724    	
;;;725    	#endif	
;;;726    
;;;727        #if 0
;;;728        printf("FLAG_PROJ_TIMER_PERIOD_1000MS : 0x%2X\r\n",FLAG_PROJ_TIMER_PERIOD_1000MS);
;;;729        printf("FLAG_PROJ_REVERSE1 : 0x%2X\r\n",FLAG_PROJ_REVERSE1);
;;;730        printf("FLAG_PROJ_REVERSE2 : 0x%2X\r\n",FLAG_PROJ_REVERSE2);
;;;731        printf("FLAG_PROJ_REVERSE3 : 0x%2X\r\n",FLAG_PROJ_REVERSE3);
;;;732        printf("FLAG_PROJ_REVERSE4 : 0x%2X\r\n",FLAG_PROJ_REVERSE4);
;;;733        printf("FLAG_PROJ_REVERSE5 : 0x%2X\r\n",FLAG_PROJ_REVERSE5);
;;;734        printf("FLAG_PROJ_REVERSE6 : 0x%2X\r\n",FLAG_PROJ_REVERSE6);
;;;735        printf("FLAG_PROJ_REVERSE7 : 0x%2X\r\n",FLAG_PROJ_REVERSE7);
;;;736        #endif
;;;737    
;;;738    }
;;;739    
                          ENDP

                  |L22.148|
                          DCD      0x04000010
                  |L22.152|
                          DCD      0x40070000
                  |L22.156|
00009c  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
0000a0  4b5f4765
0000a4  74435055
0000a8  46726571
0000ac  203a2025
0000b0  38640d0a
0000b4  00      
0000b5  00                DCB      0
0000b6  00                DCB      0
0000b7  00                DCB      0
                  |L22.184|
0000b8  434c4b5f          DCB      "CLK_GetHCLKFreq : %8d\r\n",0
0000bc  47657448
0000c0  434c4b46
0000c4  72657120
0000c8  3a202538
0000cc  640d0a00
                  |L22.208|
0000d0  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
0000d4  47657448
0000d8  58544672
0000dc  6571203a
0000e0  20253864
0000e4  0d0a00  
0000e7  00                DCB      0
                  |L22.232|
0000e8  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
0000ec  4765744c
0000f0  58544672
0000f4  6571203a
0000f8  20253864
0000fc  0d0a00  
0000ff  00                DCB      0
                  |L22.256|
000100  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
000104  47657450
000108  434c4b30
00010c  46726571
000110  203a2025
000114  38640d0a
000118  00      
000119  00                DCB      0
00011a  00                DCB      0
00011b  00                DCB      0
                  |L22.284|
00011c  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
000120  47657450
000124  434c4b31
000128  46726571
00012c  203a2025
000130  38640d0a
000134  00      
000135  00                DCB      0
000136  00                DCB      0
000137  00                DCB      0

                          AREA ||i.UARTx_Process||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_c
                          REQUIRE _printf_str
                  UARTx_Process PROC
;;;639    
;;;640    void UARTx_Process(void)
000000  b510              PUSH     {r4,lr}
;;;641    {
;;;642    	uint8_t res = 0;
;;;643    	res = UART_READ(UART0);
000002  481c              LDR      r0,|L23.116|
000004  6800              LDR      r0,[r0,#0]
000006  b2c4              UXTB     r4,r0
;;;644    
;;;645    	if (res > 0x7F)
000008  2c7f              CMP      r4,#0x7f
00000a  d904              BLS      |L23.22|
;;;646    	{
;;;647    		printf("invalid command\r\n");
00000c  e8bd4010          POP      {r4,lr}
000010  a019              ADR      r0,|L23.120|
000012  f7ffbffe          B.W      __2printf
                  |L23.22|
;;;648    	}
;;;649    	else
;;;650    	{
;;;651    		printf("press : %c\r\n" , res);
000016  4621              MOV      r1,r4
000018  a01c              ADR      r0,|L23.140|
00001a  f7fffffe          BL       __2printf
;;;652    		switch(res)
00001e  2c58              CMP      r4,#0x58
000020  d015              BEQ      |L23.78|
000022  dc0e              BGT      |L23.66|
;;;653    		{
;;;654    			case '1':
;;;655    				DEVICE_SetTxMsg_Remote_Frame(CAN_DEVICE_PORT);
000024  481d              LDR      r0,|L23.156|
000026  2c31              CMP      r4,#0x31              ;652
000028  d017              BEQ      |L23.90|
00002a  2c32              CMP      r4,#0x32              ;652
00002c  d019              BEQ      |L23.98|
;;;656    				break;
;;;657    			case '2':
;;;658    				DEVICE_Tx(CAN_DEVICE_PORT);
;;;659    				break;
;;;660    			case '3':
;;;661    				FLAG_PROJ_TRIG_CAN = 1;
00002e  481c              LDR      r0,|L23.160|
000030  2c33              CMP      r4,#0x33              ;652
000032  d01a              BEQ      |L23.106|
000034  2c34              CMP      r4,#0x34              ;652
000036  d103              BNE      |L23.64|
;;;662    				break;
;;;663    			case '4':
;;;664    				FLAG_PROJ_TRIG_CAN = 0;
000038  6801              LDR      r1,[r0,#0]  ; flag_PROJ_CTL
00003a  f0210102          BIC      r1,r1,#2
                  |L23.62|
00003e  6001              STR      r1,[r0,#0]            ;661  ; flag_PROJ_CTL
                  |L23.64|
;;;665    				break;
;;;666    
;;;667    			case 'X':
;;;668    			case 'x':
;;;669    			case 'Z':
;;;670    			case 'z':
;;;671                    SYS_UnlockReg();
;;;672    				// NVIC_SystemReset();	// Reset I/O and peripherals , only check BS(FMC_ISPCTL[1])
;;;673                    // SYS_ResetCPU();     // Not reset I/O and peripherals
;;;674                    SYS_ResetChip();    // Reset I/O and peripherals ,  BS(FMC_ISPCTL[1]) reload from CONFIG setting (CBS)	
;;;675    				break;
;;;676    		}
;;;677    	}
;;;678    }
000040  bd10              POP      {r4,pc}
                  |L23.66|
000042  2c5a              CMP      r4,#0x5a              ;652
000044  d003              BEQ      |L23.78|
000046  2c78              CMP      r4,#0x78              ;652
000048  d001              BEQ      |L23.78|
00004a  2c7a              CMP      r4,#0x7a              ;652
00004c  d1f8              BNE      |L23.64|
                  |L23.78|
00004e  f7fffffe          BL       SYS_UnlockReg
000052  e8bd4010          POP      {r4,lr}               ;674
000056  f7ffbffe          B.W      SYS_ResetChip
                  |L23.90|
00005a  e8bd4010          POP      {r4,lr}               ;655
00005e  f7ffbffe          B.W      DEVICE_SetTxMsg_Remote_Frame
                  |L23.98|
000062  e8bd4010          POP      {r4,lr}               ;658
000066  f7ffbffe          B.W      DEVICE_Tx
                  |L23.106|
00006a  6801              LDR      r1,[r0,#0]            ;661  ; flag_PROJ_CTL
00006c  f0410102          ORR      r1,r1,#2              ;661
000070  e7e5              B        |L23.62|
;;;679    
                          ENDP

000072  0000              DCW      0x0000
                  |L23.116|
                          DCD      0x40070000
                  |L23.120|
000078  696e7661          DCB      "invalid command\r\n",0
00007c  6c696420
000080  636f6d6d
000084  616e640d
000088  0a00    
00008a  00                DCB      0
00008b  00                DCB      0
                  |L23.140|
00008c  70726573          DCB      "press : %c\r\n",0
000090  73203a20
000094  25630d0a
000098  00      
000099  00                DCB      0
00009a  00                DCB      0
00009b  00                DCB      0
                  |L23.156|
                          DCD      0x400a0000
                  |L23.160|
                          DCD      ||.data||+0x10

                          AREA ||i.check_reset_source||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  check_reset_source PROC
;;;173    //
;;;174    uint8_t check_reset_source(void)
000000  b570              PUSH     {r4-r6,lr}
;;;175    {
;;;176        uint32_t src = SYS_GetResetSrc();
000002  f7fffffe          BL       SYS_GetResetSrc
;;;177    
;;;178        if ((SYS->CSERVER & SYS_CSERVER_VERSION_Msk) == 0x1)    // M48xGCAE
000006  f04f4580          MOV      r5,#0x40000000
00000a  4604              MOV      r4,r0                 ;176
00000c  f8d501f4          LDR      r0,[r5,#0x1f4]
000010  b2c0              UXTB     r0,r0
000012  2801              CMP      r0,#1
000014  d03f              BEQ      |L24.150|
;;;179        {
;;;180    		printf("PN : M48xGCAE\r\n");
;;;181        }
;;;182        else    // M48xIDAE
;;;183        {
;;;184    		printf("PN : M48xIDAE\r\n");
000016  a03c              ADR      r0,|L24.264|
                  |L24.24|
000018  f7fffffe          BL       __2printf
;;;185        }
;;;186    
;;;187        SYS->RSTSTS |= 0x1FF;
00001c  6868              LDR      r0,[r5,#4]
00001e  f24011ff          MOV      r1,#0x1ff
000022  4308              ORRS     r0,r0,r1
000024  6068              STR      r0,[r5,#4]
;;;188        printf("Reset Source <0x%08X>\r\n", src);
000026  4621              MOV      r1,r4
000028  a03b              ADR      r0,|L24.280|
00002a  f7fffffe          BL       __2printf
;;;189    
;;;190        #if 1   //DEBUG , list reset source
;;;191        if (src & BIT0)
00002e  07e0              LSLS     r0,r4,#31
000030  d002              BEQ      |L24.56|
;;;192        {
;;;193            printf("0)POR Reset Flag\r\n");       
000032  a03f              ADR      r0,|L24.304|
000034  f7fffffe          BL       __2printf
                  |L24.56|
;;;194        }
;;;195        if (src & BIT1)
000038  07a0              LSLS     r0,r4,#30
00003a  d502              BPL      |L24.66|
;;;196        {
;;;197            printf("1)NRESET Pin Reset Flag\r\n");       
00003c  a041              ADR      r0,|L24.324|
00003e  f7fffffe          BL       __2printf
                  |L24.66|
;;;198        }
;;;199        if (src & BIT2)
000042  0760              LSLS     r0,r4,#29
000044  d502              BPL      |L24.76|
;;;200        {
;;;201            printf("2)WDT Reset Flag\r\n");       
000046  a046              ADR      r0,|L24.352|
000048  f7fffffe          BL       __2printf
                  |L24.76|
;;;202        }
;;;203        if (src & BIT3)
00004c  0720              LSLS     r0,r4,#28
00004e  d502              BPL      |L24.86|
;;;204        {
;;;205            printf("3)LVR Reset Flag\r\n");       
000050  a048              ADR      r0,|L24.372|
000052  f7fffffe          BL       __2printf
                  |L24.86|
;;;206        }
;;;207        if (src & BIT4)
000056  06e0              LSLS     r0,r4,#27
000058  d502              BPL      |L24.96|
;;;208        {
;;;209            printf("4)BOD Reset Flag\r\n");       
00005a  a04b              ADR      r0,|L24.392|
00005c  f7fffffe          BL       __2printf
                  |L24.96|
;;;210        }
;;;211        if (src & BIT5)
000060  06a0              LSLS     r0,r4,#26
000062  d502              BPL      |L24.106|
;;;212        {
;;;213            printf("5)System Reset Flag \r\n");       
000064  a04d              ADR      r0,|L24.412|
000066  f7fffffe          BL       __2printf
                  |L24.106|
;;;214        }
;;;215        if (src & BIT6)
00006a  0660              LSLS     r0,r4,#25
00006c  d502              BPL      |L24.116|
;;;216        {
;;;217            printf("6)HRESET Reset Flag \r\n");       
00006e  a051              ADR      r0,|L24.436|
000070  f7fffffe          BL       __2printf
                  |L24.116|
;;;218        }
;;;219        if (src & BIT7)
000074  0620              LSLS     r0,r4,#24
000076  d502              BPL      |L24.126|
;;;220        {
;;;221            printf("7)CPU Reset Flag\r\n");       
000078  a054              ADR      r0,|L24.460|
00007a  f7fffffe          BL       __2printf
                  |L24.126|
;;;222        }
;;;223        if (src & BIT8)
00007e  05e0              LSLS     r0,r4,#23
000080  d502              BPL      |L24.136|
;;;224        {
;;;225            printf("8)CPU Lockup Reset Flag\r\n");       
000082  a057              ADR      r0,|L24.480|
000084  f7fffffe          BL       __2printf
                  |L24.136|
;;;226        }
;;;227        #endif
;;;228        
;;;229        if (src & SYS_RSTSTS_PORF_Msk) {
000088  07e0              LSLS     r0,r4,#31
00008a  d006              BEQ      |L24.154|
;;;230            SYS_ClearResetSrc(SYS_RSTSTS_PORF_Msk);
00008c  2001              MOVS     r0,#1
00008e  f7fffffe          BL       SYS_ClearResetSrc
;;;231            
;;;232            printf("power on from POR\r\n");
000092  a05a              ADR      r0,|L24.508|
;;;233            return FALSE;
000094  e032              B        |L24.252|
                  |L24.150|
000096  a05e              ADR      r0,|L24.528|
000098  e7be              B        |L24.24|
                  |L24.154|
;;;234        }    
;;;235        else if (src & SYS_RSTSTS_PINRF_Msk)
00009a  07a0              LSLS     r0,r4,#30
00009c  d504              BPL      |L24.168|
;;;236        {
;;;237            SYS_ClearResetSrc(SYS_RSTSTS_PINRF_Msk);
00009e  2002              MOVS     r0,#2
0000a0  f7fffffe          BL       SYS_ClearResetSrc
;;;238            
;;;239            printf("power on from nRESET pin\r\n");
0000a4  a05e              ADR      r0,|L24.544|
;;;240            return FALSE;
0000a6  e029              B        |L24.252|
                  |L24.168|
;;;241        } 
;;;242        else if (src & SYS_RSTSTS_WDTRF_Msk)
0000a8  0760              LSLS     r0,r4,#29
0000aa  d504              BPL      |L24.182|
;;;243        {
;;;244            SYS_ClearResetSrc(SYS_RSTSTS_WDTRF_Msk);
0000ac  2004              MOVS     r0,#4
0000ae  f7fffffe          BL       SYS_ClearResetSrc
;;;245            
;;;246            printf("power on from WDT Reset\r\n");
0000b2  a062              ADR      r0,|L24.572|
;;;247            return FALSE;
0000b4  e022              B        |L24.252|
                  |L24.182|
;;;248        }    
;;;249        else if (src & SYS_RSTSTS_LVRF_Msk)
0000b6  0720              LSLS     r0,r4,#28
0000b8  d504              BPL      |L24.196|
;;;250        {
;;;251            SYS_ClearResetSrc(SYS_RSTSTS_LVRF_Msk);
0000ba  2008              MOVS     r0,#8
0000bc  f7fffffe          BL       SYS_ClearResetSrc
;;;252            
;;;253            printf("power on from LVR Reset\r\n");
0000c0  a065              ADR      r0,|L24.600|
;;;254            return FALSE;
0000c2  e01b              B        |L24.252|
                  |L24.196|
;;;255        }    
;;;256        else if (src & SYS_RSTSTS_BODRF_Msk)
0000c4  06e0              LSLS     r0,r4,#27
0000c6  d504              BPL      |L24.210|
;;;257        {
;;;258            SYS_ClearResetSrc(SYS_RSTSTS_BODRF_Msk);
0000c8  2010              MOVS     r0,#0x10
0000ca  f7fffffe          BL       SYS_ClearResetSrc
;;;259            
;;;260            printf("power on from BOD Reset\r\n");
0000ce  a069              ADR      r0,|L24.628|
;;;261            return FALSE;
0000d0  e014              B        |L24.252|
                  |L24.210|
;;;262        }    
;;;263        else if (src & SYS_RSTSTS_SYSRF_Msk)
0000d2  06a0              LSLS     r0,r4,#26
0000d4  d504              BPL      |L24.224|
;;;264        {
;;;265            SYS_ClearResetSrc(SYS_RSTSTS_SYSRF_Msk);
0000d6  2020              MOVS     r0,#0x20
0000d8  f7fffffe          BL       SYS_ClearResetSrc
;;;266            
;;;267            printf("power on from System Reset\r\n");
0000dc  a06c              ADR      r0,|L24.656|
;;;268            return FALSE;
0000de  e00d              B        |L24.252|
                  |L24.224|
;;;269        } 
;;;270        else if (src & SYS_RSTSTS_CPURF_Msk)
0000e0  0620              LSLS     r0,r4,#24
0000e2  d504              BPL      |L24.238|
;;;271        {
;;;272            SYS_ClearResetSrc(SYS_RSTSTS_CPURF_Msk);
0000e4  2080              MOVS     r0,#0x80
0000e6  f7fffffe          BL       SYS_ClearResetSrc
;;;273    
;;;274            printf("power on from CPU reset\r\n");
0000ea  a071              ADR      r0,|L24.688|
;;;275            return FALSE;         
0000ec  e006              B        |L24.252|
                  |L24.238|
;;;276        }    
;;;277        else if (src & SYS_RSTSTS_CPULKRF_Msk)
0000ee  05e0              LSLS     r0,r4,#23
0000f0  d508              BPL      |L24.260|
;;;278        {
;;;279            SYS_ClearResetSrc(SYS_RSTSTS_CPULKRF_Msk);
0000f2  f44f7080          MOV      r0,#0x100
0000f6  f7fffffe          BL       SYS_ClearResetSrc
;;;280            
;;;281            printf("power on from CPU Lockup Reset\r\n");
0000fa  a074              ADR      r0,|L24.716|
                  |L24.252|
;;;282            return FALSE;
;;;283        }   
;;;284        
;;;285        printf("power on from unhandle reset source\r\n");
0000fc  f7fffffe          BL       __2printf
;;;286        return FALSE;
000100  2000              MOVS     r0,#0
;;;287    }
000102  bd70              POP      {r4-r6,pc}
                  |L24.260|
000104  a07a              ADR      r0,|L24.752|
000106  e7f9              B        |L24.252|
;;;288    
                          ENDP

                  |L24.264|
000108  504e203a          DCB      "PN : M48xIDAE\r\n",0
00010c  204d3438
000110  78494441
000114  450d0a00
                  |L24.280|
000118  52657365          DCB      "Reset Source <0x%08X>\r\n",0
00011c  7420536f
000120  75726365
000124  203c3078
000128  25303858
00012c  3e0d0a00
                  |L24.304|
000130  3029504f          DCB      "0)POR Reset Flag\r\n",0
000134  52205265
000138  73657420
00013c  466c6167
000140  0d0a00  
000143  00                DCB      0
                  |L24.324|
000144  31294e52          DCB      "1)NRESET Pin Reset Flag\r\n",0
000148  45534554
00014c  2050696e
000150  20526573
000154  65742046
000158  6c61670d
00015c  0a00    
00015e  00                DCB      0
00015f  00                DCB      0
                  |L24.352|
000160  32295744          DCB      "2)WDT Reset Flag\r\n",0
000164  54205265
000168  73657420
00016c  466c6167
000170  0d0a00  
000173  00                DCB      0
                  |L24.372|
000174  33294c56          DCB      "3)LVR Reset Flag\r\n",0
000178  52205265
00017c  73657420
000180  466c6167
000184  0d0a00  
000187  00                DCB      0
                  |L24.392|
000188  3429424f          DCB      "4)BOD Reset Flag\r\n",0
00018c  44205265
000190  73657420
000194  466c6167
000198  0d0a00  
00019b  00                DCB      0
                  |L24.412|
00019c  35295379          DCB      "5)System Reset Flag \r\n",0
0001a0  7374656d
0001a4  20526573
0001a8  65742046
0001ac  6c616720
0001b0  0d0a00  
0001b3  00                DCB      0
                  |L24.436|
0001b4  36294852          DCB      "6)HRESET Reset Flag \r\n",0
0001b8  45534554
0001bc  20526573
0001c0  65742046
0001c4  6c616720
0001c8  0d0a00  
0001cb  00                DCB      0
                  |L24.460|
0001cc  37294350          DCB      "7)CPU Reset Flag\r\n",0
0001d0  55205265
0001d4  73657420
0001d8  466c6167
0001dc  0d0a00  
0001df  00                DCB      0
                  |L24.480|
0001e0  38294350          DCB      "8)CPU Lockup Reset Flag\r\n",0
0001e4  55204c6f
0001e8  636b7570
0001ec  20526573
0001f0  65742046
0001f4  6c61670d
0001f8  0a00    
0001fa  00                DCB      0
0001fb  00                DCB      0
                  |L24.508|
0001fc  706f7765          DCB      "power on from POR\r\n",0
000200  72206f6e
000204  2066726f
000208  6d20504f
00020c  520d0a00
                  |L24.528|
000210  504e203a          DCB      "PN : M48xGCAE\r\n",0
000214  204d3438
000218  78474341
00021c  450d0a00
                  |L24.544|
000220  706f7765          DCB      "power on from nRESET pin\r\n",0
000224  72206f6e
000228  2066726f
00022c  6d206e52
000230  45534554
000234  2070696e
000238  0d0a00  
00023b  00                DCB      0
                  |L24.572|
00023c  706f7765          DCB      "power on from WDT Reset\r\n",0
000240  72206f6e
000244  2066726f
000248  6d205744
00024c  54205265
000250  7365740d
000254  0a00    
000256  00                DCB      0
000257  00                DCB      0
                  |L24.600|
000258  706f7765          DCB      "power on from LVR Reset\r\n",0
00025c  72206f6e
000260  2066726f
000264  6d204c56
000268  52205265
00026c  7365740d
000270  0a00    
000272  00                DCB      0
000273  00                DCB      0
                  |L24.628|
000274  706f7765          DCB      "power on from BOD Reset\r\n",0
000278  72206f6e
00027c  2066726f
000280  6d20424f
000284  44205265
000288  7365740d
00028c  0a00    
00028e  00                DCB      0
00028f  00                DCB      0
                  |L24.656|
000290  706f7765          DCB      "power on from System Reset\r\n",0
000294  72206f6e
000298  2066726f
00029c  6d205379
0002a0  7374656d
0002a4  20526573
0002a8  65740d0a
0002ac  00      
0002ad  00                DCB      0
0002ae  00                DCB      0
0002af  00                DCB      0
                  |L24.688|
0002b0  706f7765          DCB      "power on from CPU reset\r\n",0
0002b4  72206f6e
0002b8  2066726f
0002bc  6d204350
0002c0  55207265
0002c4  7365740d
0002c8  0a00    
0002ca  00                DCB      0
0002cb  00                DCB      0
                  |L24.716|
0002cc  706f7765          DCB      "power on from CPU Lockup Reset\r\n",0
0002d0  72206f6e
0002d4  2066726f
0002d8  6d204350
0002dc  55204c6f
0002e0  636b7570
0002e4  20526573
0002e8  65740d0a
0002ec  00      
0002ed  00                DCB      0
0002ee  00                DCB      0
0002ef  00                DCB      0
                  |L24.752|
0002f0  706f7765          DCB      "power on from unhandle reset source\r\n",0
0002f4  72206f6e
0002f8  2066726f
0002fc  6d20756e
000300  68616e64
000304  6c652072
000308  65736574
00030c  20736f75
000310  7263650d
000314  0a00    
000316  00                DCB      0
000317  00                DCB      0

                          AREA ||i.delay_ms||, CODE, READONLY, ALIGN=2

                  delay_ms PROC
;;;142    
;;;143    void delay_ms(uint16_t ms)
000000  4b07              LDR      r3,|L25.32|
;;;144    {
000002  b510              PUSH     {r4,lr}
000004  6899              LDR      r1,[r3,#8]  ; counter_tick
;;;145    	#if 1
;;;146        uint32_t tickstart = get_tick();
;;;147        uint32_t wait = ms;
;;;148    	uint32_t tmp = 0;
;;;149    	
;;;150        while (1)
;;;151        {
;;;152    		if (get_tick() > tickstart)	// tickstart = 59000 , tick_counter = 60000
;;;153    		{
;;;154    			tmp = get_tick() - tickstart;
;;;155    		}
;;;156    		else // tickstart = 59000 , tick_counter = 2048
;;;157    		{
;;;158    			tmp = 60000 -  tickstart + get_tick();
000006  f64e2260          MOV      r2,#0xea60
00000a  1a54              SUBS     r4,r2,r1
                  |L25.12|
00000c  689a              LDR      r2,[r3,#8]  ; counter_tick
00000e  428a              CMP      r2,r1                 ;152
000010  689a              LDR      r2,[r3,#8]            ;152  ; counter_tick
000012  d901              BLS      |L25.24|
000014  1a52              SUBS     r2,r2,r1              ;154
000016  e000              B        |L25.26|
                  |L25.24|
000018  4422              ADD      r2,r2,r4
                  |L25.26|
;;;159    		}		
;;;160    		
;;;161    		if (tmp > wait)
00001a  4282              CMP      r2,r0
00001c  d9f6              BLS      |L25.12|
;;;162    			break;
;;;163        }
;;;164    	
;;;165    	#else
;;;166    	TIMER_Delay(TIMER0, 1000*ms);
;;;167    	#endif
;;;168    }
00001e  bd10              POP      {r4,pc}
;;;169    
                          ENDP

                  |L25.32|
                          DCD      ||.data||

                          AREA ||i.get_systick||, CODE, READONLY, ALIGN=2

                  get_systick PROC
;;;61     
;;;62     unsigned int get_systick(void)
000000  4801              LDR      r0,|L26.8|
;;;63     {
;;;64     	return (counter_systick);
000002  6840              LDR      r0,[r0,#4]  ; counter_systick
;;;65     }
000004  4770              BX       lr
;;;66     
                          ENDP

000006  0000              DCW      0x0000
                  |L26.8|
                          DCD      ||.data||

                          AREA ||i.get_tick||, CODE, READONLY, ALIGN=2

                  get_tick PROC
;;;123    
;;;124    uint32_t get_tick(void)
000000  4801              LDR      r0,|L27.8|
;;;125    {
;;;126    	return (counter_tick);
000002  6880              LDR      r0,[r0,#8]  ; counter_tick
;;;127    }
000004  4770              BX       lr
;;;128    
                          ENDP

000006  0000              DCW      0x0000
                  |L27.8|
                          DCD      ||.data||

                          AREA ||i.loop||, CODE, READONLY, ALIGN=2

                  loop PROC
;;;615    
;;;616    void loop(void)
000000  480a              LDR      r0,|L28.44|
000002  6840              LDR      r0,[r0,#4]  ; counter_systick
;;;617    {
;;;618    	// static uint32_t LOG1 = 0;
;;;619    	// static uint32_t LOG2 = 0;
;;;620    
;;;621        if ((get_systick() % 1000) == 0)
;;;622        {
;;;623            // printf("%s(systick) : %4d\r\n",__FUNCTION__,LOG2++);    
;;;624        }
;;;625    
;;;626        if (FLAG_PROJ_TIMER_PERIOD_1000MS)//(is_flag_set(flag_timer_period_1000ms))
000004  4909              LDR      r1,|L28.44|
000006  3110              ADDS     r1,r1,#0x10
000008  6808              LDR      r0,[r1,#0]  ; flag_PROJ_CTL
00000a  07c2              LSLS     r2,r0,#31
00000c  d007              BEQ      |L28.30|
;;;627        {
;;;628            FLAG_PROJ_TIMER_PERIOD_1000MS = 0;//set_flag(flag_timer_period_1000ms ,DISABLE);
00000e  f0200001          BIC      r0,r0,#1
;;;629    
;;;630            // printf("%s(timer) : %4d\r\n",__FUNCTION__,LOG1++);
;;;631            PH0 ^= 1;             
000012  6008              STR      r0,[r1,#0]  ; flag_PROJ_CTL
000014  4806              LDR      r0,|L28.48|
000016  6802              LDR      r2,[r0,#0]
000018  f0820201          EOR      r2,r2,#1
00001c  6002              STR      r2,[r0,#0]
                  |L28.30|
;;;632        }
;;;633    
;;;634        if (FLAG_PROJ_TRIG_CAN)
00001e  7808              LDRB     r0,[r1,#0]  ; flag_PROJ_CTL
000020  0780              LSLS     r0,r0,#30
000022  d502              BPL      |L28.42|
;;;635        {        
;;;636            DEVICE_Tx(CAN_DEVICE_PORT);
000024  4803              LDR      r0,|L28.52|
000026  f7ffbffe          B.W      DEVICE_Tx
                  |L28.42|
;;;637        }
;;;638    }
00002a  4770              BX       lr
;;;639    
                          ENDP

                  |L28.44|
                          DCD      ||.data||
                  |L28.48|
                          DCD      0x400049c0
                  |L28.52|
                          DCD      0x400a0000

                          AREA ||i.main||, CODE, READONLY, ALIGN=1

                  main PROC
;;;817    
;;;818    int main()
000000  f7fffffe          BL       SYS_Init
;;;819    {
;;;820        SYS_Init();
;;;821    
;;;822    	GPIO_Init();
000004  f7fffffe          BL       GPIO_Init
;;;823    	UART0_Init();
000008  f7fffffe          BL       UART0_Init
;;;824    	TIMER1_Init();
00000c  f7fffffe          BL       TIMER1_Init
;;;825        check_reset_source();
000010  f7fffffe          BL       check_reset_source
;;;826    
;;;827        SysTick_enable(1000);
000014  f44f707a          MOV      r0,#0x3e8
000018  f7fffffe          BL       SysTick_enable
;;;828        #if defined (ENABLE_TICK_EVENT)
;;;829        TickSetTickEvent(1000, TickCallback_processA);  // 1000 ms
;;;830        TickSetTickEvent(5000, TickCallback_processB);  // 5000 ms
;;;831        #endif
;;;832    
;;;833        RS_PIN_Init();
00001c  f7fffffe          BL       RS_PIN_Init
;;;834    	CAN_Init();
000020  f7fffffe          BL       CAN_Init
;;;835    	CAN_Setup();
000024  f7fffffe          BL       CAN_Setup
                  |L29.40|
;;;836    
;;;837        /* Got no where to go, just loop forever */
;;;838        while(1)
;;;839        {
;;;840            loop();
000028  f7fffffe          BL       loop
00002c  e7fc              B        |L29.40|
;;;841    
;;;842        }
;;;843    }
;;;844    
                          ENDP


                          AREA ||i.set_systick||, CODE, READONLY, ALIGN=2

                  set_systick PROC
;;;66     
;;;67     void set_systick(unsigned int t)
000000  4901              LDR      r1,|L30.8|
;;;68     {
;;;69     	counter_systick = t;
000002  6048              STR      r0,[r1,#4]  ; counter_systick
;;;70     }
000004  4770              BX       lr
;;;71     
                          ENDP

000006  0000              DCW      0x0000
                  |L30.8|
                          DCD      ||.data||

                          AREA ||i.set_tick||, CODE, READONLY, ALIGN=2

                  set_tick PROC
;;;128    
;;;129    void set_tick(uint32_t t)
000000  4901              LDR      r1,|L31.8|
;;;130    {
;;;131    	counter_tick = t;
000002  6088              STR      r0,[r1,#8]  ; counter_tick
;;;132    }
000004  4770              BX       lr
;;;133    
                          ENDP

000006  0000              DCW      0x0000
                  |L31.8|
                          DCD      ||.data||

                          AREA ||i.systick_counter||, CODE, READONLY, ALIGN=2

                  systick_counter PROC
;;;71     
;;;72     void systick_counter(void)
000000  4802              LDR      r0,|L32.12|
;;;73     {
;;;74     	counter_systick++;
000002  6841              LDR      r1,[r0,#4]  ; counter_systick
000004  1c49              ADDS     r1,r1,#1
000006  6041              STR      r1,[r0,#4]  ; counter_systick
;;;75     }
000008  4770              BX       lr
;;;76     
                          ENDP

00000a  0000              DCW      0x0000
                  |L32.12|
                          DCD      ||.data||

                          AREA ||i.tick_counter||, CODE, READONLY, ALIGN=2

                  tick_counter PROC
;;;133    
;;;134    void tick_counter(void)
000000  4805              LDR      r0,|L33.24|
;;;135    {
;;;136    	counter_tick++;
000002  6881              LDR      r1,[r0,#8]  ; counter_tick
000004  1c49              ADDS     r1,r1,#1
000006  6081              STR      r1,[r0,#8]  ; counter_tick
000008  6881              LDR      r1,[r0,#8]  ; counter_tick
;;;137        if (get_tick() >= 60000)
00000a  f64e2260          MOV      r2,#0xea60
00000e  4291              CMP      r1,r2
000010  d301              BCC      |L33.22|
;;;138        {
;;;139            set_tick(0);
000012  2100              MOVS     r1,#0
000014  6081              STR      r1,[r0,#8]  ; counter_tick
                  |L33.22|
;;;140        }
;;;141    }
000016  4770              BX       lr
;;;142    
                          ENDP

                  |L33.24|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  rrMsg
                          %        24

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  44455649          DCB      0x44,0x45,0x56,0x49
000004  43455f53          DCB      0x43,0x45,0x5f,0x53
000008  65745478          DCB      0x65,0x74,0x54,0x78
00000c  4d73675f          DCB      0x4d,0x73,0x67,0x5f
000010  52656d6f          DCB      0x52,0x65,0x6d,0x6f
000014  74655f46          DCB      0x74,0x65,0x5f,0x46
000018  72616d65          DCB      0x72,0x61,0x6d,0x65
00001c  00                DCB      0x00
                  |symbol_number.102|
00001d  444556            DCB      0x44,0x45,0x56
000020  4943455f          DCB      0x49,0x43,0x45,0x5f
000024  547800            DCB      0x54,0x78,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  ||cnt||
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  counter_systick
                          DCD      0x00000000
                  counter_tick
                          DCD      0x00000000
                  |symbol_number.104|
                          DCD      0x00000000
                  flag_PROJ_CTL
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_6b33c82f____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_6b33c82f____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_6b33c82f____REVSH|
#line 402
|__asm___6_main_c_6b33c82f____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_6b33c82f____RRX|
#line 587
|__asm___6_main_c_6b33c82f____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
