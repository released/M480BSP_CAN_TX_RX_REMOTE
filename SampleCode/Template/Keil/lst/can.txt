; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\can.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\can.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -I..\..\Template -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=528 --omf_browse=.\obj\can.crf ..\..\..\Library\StdDriver\src\can.c]
                          THUMB

                          AREA ||i.CAN_BasicReceiveMsg||, CODE, READONLY, ALIGN=1

                  CAN_BasicReceiveMsg PROC
;;;486      */
;;;487    int32_t CAN_BasicReceiveMsg(CAN_T *tCAN, STR_CANMSG_T* pCanMsg)
000000  b510              PUSH     {r4,lr}
;;;488    {
;;;489        int32_t rev = 1l;
;;;490    
;;;491        if((tCAN->IF[1].MCON & CAN_IF_MCON_NEWDAT_Msk) == 0ul)
000002  f8d03098          LDR      r3,[r0,#0x98]
000006  2201              MOVS     r2,#1                 ;489
000008  041b              LSLS     r3,r3,#16
00000a  d401              BMI      |L1.16|
;;;492        {
;;;493            /* In basic mode, receive data always save in IF2 */
;;;494            rev = 0; /* return FALSE */
00000c  2200              MOVS     r2,#0
00000e  e03a              B        |L1.134|
                  |L1.16|
;;;495        }
;;;496        else
;;;497        {
;;;498    
;;;499            tCAN->STATUS &= (~CAN_STATUS_RXOK_Msk);
000010  6843              LDR      r3,[r0,#4]
000012  f0230310          BIC      r3,r3,#0x10
000016  6043              STR      r3,[r0,#4]
;;;500    
;;;501            tCAN->IF[1].CMASK = CAN_IF_CMASK_ARB_Msk
000018  2333              MOVS     r3,#0x33
00001a  f8c03084          STR      r3,[r0,#0x84]
;;;502                                | CAN_IF_CMASK_CONTROL_Msk
;;;503                                | CAN_IF_CMASK_DATAA_Msk
;;;504                                | CAN_IF_CMASK_DATAB_Msk;
;;;505    
;;;506            if((tCAN->IF[1].ARB2 & CAN_IF_ARB2_XTD_Msk) == 0ul)
00001e  f8d03094          LDR      r3,[r0,#0x94]
000022  045b              LSLS     r3,r3,#17
000024  d406              BMI      |L1.52|
;;;507            {
;;;508                /* standard ID*/
;;;509                pCanMsg->IdType = CAN_STD_ID;
000026  2300              MOVS     r3,#0
;;;510                pCanMsg->Id = (tCAN->IF[1].ARB2 >> 2) & 0x07FFul;
000028  600b              STR      r3,[r1,#0]
00002a  f8d03094          LDR      r3,[r0,#0x94]
00002e  f3c3038a          UBFX     r3,r3,#2,#11
000032  e009              B        |L1.72|
                  |L1.52|
;;;511    
;;;512            }
;;;513            else
;;;514            {
;;;515                /* extended ID*/
;;;516                pCanMsg->IdType = CAN_EXT_ID;
000034  2301              MOVS     r3,#1
;;;517                pCanMsg->Id  = (tCAN->IF[1].ARB2 & 0x1FFFul) << 16;
000036  600b              STR      r3,[r1,#0]
000038  f8d03094          LDR      r3,[r0,#0x94]
00003c  04db              LSLS     r3,r3,#19
00003e  08db              LSRS     r3,r3,#3
;;;518                pCanMsg->Id |= (uint32_t)tCAN->IF[1].ARB1;
000040  608b              STR      r3,[r1,#8]
000042  f8d04090          LDR      r4,[r0,#0x90]
000046  4323              ORRS     r3,r3,r4
                  |L1.72|
;;;519            }
;;;520    
;;;521            pCanMsg->FrameType = (((tCAN->IF[1].ARB2 & CAN_IF_ARB2_DIR_Msk) >> CAN_IF_ARB2_DIR_Pos)) ? 0ul : 1ul;
000048  608b              STR      r3,[r1,#8]
00004a  f8503f94          LDR      r3,[r0,#0x94]!
00004e  f3433340          SBFX     r3,r3,#13,#1
000052  1c5b              ADDS     r3,r3,#1
;;;522    
;;;523            pCanMsg->DLC     = (uint8_t)(tCAN->IF[1].MCON & CAN_IF_MCON_DLC_Msk);
000054  604b              STR      r3,[r1,#4]
000056  6843              LDR      r3,[r0,#4]
000058  f003030f          AND      r3,r3,#0xf
00005c  730b              STRB     r3,[r1,#0xc]
;;;524            pCanMsg->Data[0] = (uint8_t)(tCAN->IF[1].DAT_A1 & CAN_IF_DAT_A1_DATA0_Msk);
00005e  6883              LDR      r3,[r0,#8]
000060  734b              STRB     r3,[r1,#0xd]
;;;525            pCanMsg->Data[1] = (uint8_t)((tCAN->IF[1].DAT_A1 & CAN_IF_DAT_A1_DATA1_Msk) >> CAN_IF_DAT_A1_DATA1_Pos);
000062  6883              LDR      r3,[r0,#8]
000064  0a1b              LSRS     r3,r3,#8
000066  738b              STRB     r3,[r1,#0xe]
;;;526            pCanMsg->Data[2] = (uint8_t)(tCAN->IF[1].DAT_A2 & CAN_IF_DAT_A2_DATA2_Msk);
000068  68c3              LDR      r3,[r0,#0xc]
00006a  73cb              STRB     r3,[r1,#0xf]
;;;527            pCanMsg->Data[3] = (uint8_t)((tCAN->IF[1].DAT_A2 & CAN_IF_DAT_A2_DATA3_Msk) >> CAN_IF_DAT_A2_DATA3_Pos);
00006c  68c3              LDR      r3,[r0,#0xc]
00006e  0a1b              LSRS     r3,r3,#8
000070  740b              STRB     r3,[r1,#0x10]
;;;528            pCanMsg->Data[4] = (uint8_t)(tCAN->IF[1].DAT_B1 & CAN_IF_DAT_B1_DATA4_Msk);
000072  6903              LDR      r3,[r0,#0x10]
000074  744b              STRB     r3,[r1,#0x11]
;;;529            pCanMsg->Data[5] = (uint8_t)((tCAN->IF[1].DAT_B1 & CAN_IF_DAT_B1_DATA5_Msk) >> CAN_IF_DAT_B1_DATA5_Pos);
000076  6903              LDR      r3,[r0,#0x10]
000078  0a1b              LSRS     r3,r3,#8
00007a  748b              STRB     r3,[r1,#0x12]
;;;530            pCanMsg->Data[6] = (uint8_t)(tCAN->IF[1].DAT_B2 & CAN_IF_DAT_B2_DATA6_Msk);
00007c  6943              LDR      r3,[r0,#0x14]
00007e  74cb              STRB     r3,[r1,#0x13]
;;;531            pCanMsg->Data[7] = (uint8_t)((tCAN->IF[1].DAT_B2 & CAN_IF_DAT_B2_DATA7_Msk) >> CAN_IF_DAT_B2_DATA7_Pos);
000080  6940              LDR      r0,[r0,#0x14]
000082  0a00              LSRS     r0,r0,#8
000084  7508              STRB     r0,[r1,#0x14]
                  |L1.134|
;;;532        }
;;;533    
;;;534        return rev;
000086  4610              MOV      r0,r2
;;;535    }
000088  bd10              POP      {r4,pc}
;;;536    
                          ENDP


                          AREA ||i.CAN_BasicSendMsg||, CODE, READONLY, ALIGN=2

                  CAN_BasicSendMsg PROC
;;;398      */
;;;399    int32_t CAN_BasicSendMsg(CAN_T *tCAN, STR_CANMSG_T* pCanMsg)
000000  b530              PUSH     {r4,r5,lr}
;;;400    {
;;;401        uint32_t i = 0ul;
;;;402        int32_t rev = 1l;
;;;403        uint32_t u32TimeOutCount = SystemCoreClock; // 1 second timeout
000002  4c2a              LDR      r4,|L2.172|
000004  2200              MOVS     r2,#0                 ;401
000006  2301              MOVS     r3,#1                 ;402
000008  6824              LDR      r4,[r4,#0]  ; SystemCoreClock
00000a  e005              B        |L2.24|
                  |L2.12|
00000c  1c52              ADDS     r2,r2,#1              ;400
;;;404    
;;;405        while(tCAN->IF[0].CREQ & CAN_IF_CREQ_BUSY_Msk)
;;;406        {
;;;407            i++;
;;;408            if(i > u32TimeOutCount) return -1;
00000e  42a2              CMP      r2,r4
000010  d902              BLS      |L2.24|
000012  f04f30ff          MOV      r0,#0xffffffff
;;;409        }
;;;410    
;;;411        tCAN->STATUS &= (~CAN_STATUS_TXOK_Msk);
;;;412    
;;;413        if(pCanMsg->IdType == CAN_STD_ID)
;;;414        {
;;;415            /* standard ID*/
;;;416            tCAN->IF[0].ARB1 = 0ul;
;;;417            tCAN->IF[0].ARB2 = (((pCanMsg->Id) & 0x7FFul) << 2ul) ;
;;;418        }
;;;419        else
;;;420        {
;;;421            /* extended ID*/
;;;422            tCAN->IF[0].ARB1 = (pCanMsg->Id) & 0xFFFFul;
;;;423            tCAN->IF[0].ARB2 = ((pCanMsg->Id) & 0x1FFF0000ul) >> 16ul  | CAN_IF_ARB2_XTD_Msk;
;;;424    
;;;425        }
;;;426    
;;;427        if(pCanMsg->FrameType)
;;;428        {
;;;429            tCAN->IF[0].ARB2 |= CAN_IF_ARB2_DIR_Msk;
;;;430        }
;;;431        else
;;;432        {
;;;433            tCAN->IF[0].ARB2 &= (~CAN_IF_ARB2_DIR_Msk);
;;;434        }
;;;435    
;;;436        tCAN->IF[0].MCON = (tCAN->IF[0].MCON & (~CAN_IF_MCON_DLC_Msk)) | pCanMsg->DLC;
;;;437        tCAN->IF[0].DAT_A1 = (uint16_t)((uint16_t)((uint16_t)pCanMsg->Data[1] << 8) | pCanMsg->Data[0]);
;;;438        tCAN->IF[0].DAT_A2 = (uint16_t)((uint16_t)((uint16_t)pCanMsg->Data[3] << 8) | pCanMsg->Data[2]);
;;;439        tCAN->IF[0].DAT_B1 = (uint16_t)((uint16_t)((uint16_t)pCanMsg->Data[5] << 8) | pCanMsg->Data[4]);
;;;440        tCAN->IF[0].DAT_B2 = (uint16_t)((uint16_t)((uint16_t)pCanMsg->Data[7] << 8) | pCanMsg->Data[6]);
;;;441    
;;;442        /* request transmission*/
;;;443        tCAN->IF[0].CREQ &= (~CAN_IF_CREQ_BUSY_Msk);
;;;444        if(tCAN->IF[0].CREQ & CAN_IF_CREQ_BUSY_Msk)
;;;445        {
;;;446            /* Cannot clear busy for sending ...*/
;;;447            rev = 0l; /* return FALSE */
;;;448        }
;;;449        else
;;;450        {
;;;451            tCAN->IF[0].CREQ |= CAN_IF_CREQ_BUSY_Msk;  /* sending */
;;;452    
;;;453            for(i = 0ul; i < 0xFFFFFul; i++)
;;;454            {
;;;455                if((tCAN->IF[0].CREQ & CAN_IF_CREQ_BUSY_Msk) == 0ul)
;;;456                {
;;;457                    break;
;;;458                }
;;;459                else
;;;460                {
;;;461                }
;;;462            }
;;;463    
;;;464            if(i >= 0xFFFFFul)
;;;465            {
;;;466                /* Cannot send out... */
;;;467                rev = 0l; /* return FALSE */
;;;468            }
;;;469            else
;;;470            {
;;;471            }
;;;472        }
;;;473    
;;;474        return rev;
;;;475    }
000016  bd30              POP      {r4,r5,pc}
                  |L2.24|
000018  6a05              LDR      r5,[r0,#0x20]         ;405
00001a  042d              LSLS     r5,r5,#16             ;405
00001c  d4f6              BMI      |L2.12|
00001e  6842              LDR      r2,[r0,#4]            ;411
000020  f0220208          BIC      r2,r2,#8              ;411
000024  6042              STR      r2,[r0,#4]            ;411
000026  680a              LDR      r2,[r1,#0]            ;413
000028  b17a              CBZ      r2,|L2.74|
00002a  890a              LDRH     r2,[r1,#8]            ;422
00002c  b292              UXTH     r2,r2                 ;422
00002e  6302              STR      r2,[r0,#0x30]         ;422
000030  688a              LDR      r2,[r1,#8]            ;423
000032  f3c2420c          UBFX     r2,r2,#16,#13         ;423
000036  f4424280          ORR      r2,r2,#0x4000         ;423
                  |L2.58|
00003a  6342              STR      r2,[r0,#0x34]         ;423
00003c  684a              LDR      r2,[r1,#4]            ;427
00003e  2a00              CMP      r2,#0                 ;427
000040  6b42              LDR      r2,[r0,#0x34]         ;433
000042  d008              BEQ      |L2.86|
000044  f4425200          ORR      r2,r2,#0x2000         ;429
000048  e007              B        |L2.90|
                  |L2.74|
00004a  2200              MOVS     r2,#0                 ;416
00004c  6302              STR      r2,[r0,#0x30]         ;416
00004e  890a              LDRH     r2,[r1,#8]            ;417
000050  0552              LSLS     r2,r2,#21             ;417
000052  0cd2              LSRS     r2,r2,#19             ;417
000054  e7f1              B        |L2.58|
                  |L2.86|
000056  f4225200          BIC      r2,r2,#0x2000         ;433
                  |L2.90|
00005a  6342              STR      r2,[r0,#0x34]         ;433
00005c  6b82              LDR      r2,[r0,#0x38]         ;436
00005e  7b0c              LDRB     r4,[r1,#0xc]          ;436
000060  f022020f          BIC      r2,r2,#0xf            ;436
000064  4322              ORRS     r2,r2,r4              ;436
000066  6382              STR      r2,[r0,#0x38]         ;436
000068  f8312f0d          LDRH     r2,[r1,#0xd]!         ;437
00006c  63c2              STR      r2,[r0,#0x3c]         ;437
00006e  884a              LDRH     r2,[r1,#2]            ;438
000070  6402              STR      r2,[r0,#0x40]         ;438
000072  888a              LDRH     r2,[r1,#4]            ;439
000074  6442              STR      r2,[r0,#0x44]         ;439
000076  88c9              LDRH     r1,[r1,#6]            ;440
000078  6481              STR      r1,[r0,#0x48]         ;440
00007a  6a01              LDR      r1,[r0,#0x20]         ;443
00007c  f4214100          BIC      r1,r1,#0x8000         ;443
000080  6201              STR      r1,[r0,#0x20]         ;443
000082  6a01              LDR      r1,[r0,#0x20]         ;444
000084  0409              LSLS     r1,r1,#16             ;444
000086  d40d              BMI      |L2.164|
000088  6a01              LDR      r1,[r0,#0x20]         ;451
00008a  f4414100          ORR      r1,r1,#0x8000         ;451
00008e  6201              STR      r1,[r0,#0x20]         ;451
000090  4a07              LDR      r2,|L2.176|
000092  2100              MOVS     r1,#0                 ;453
                  |L2.148|
000094  6a04              LDR      r4,[r0,#0x20]         ;455
000096  0424              LSLS     r4,r4,#16             ;455
000098  d502              BPL      |L2.160|
00009a  1c49              ADDS     r1,r1,#1              ;455
00009c  4291              CMP      r1,r2                 ;453
00009e  d3f9              BCC      |L2.148|
                  |L2.160|
0000a0  4291              CMP      r1,r2                 ;464
0000a2  d300              BCC      |L2.166|
                  |L2.164|
0000a4  2300              MOVS     r3,#0                 ;467
                  |L2.166|
0000a6  4618              MOV      r0,r3                 ;474
0000a8  bd30              POP      {r4,r5,pc}
;;;476    
                          ENDP

0000aa  0000              DCW      0x0000
                  |L2.172|
                          DCD      SystemCoreClock
                  |L2.176|
                          DCD      0x000fffff

                          AREA ||i.CAN_CLR_INT_PENDING_BIT||, CODE, READONLY, ALIGN=1

                  CAN_CLR_INT_PENDING_BIT PROC
;;;1302     */
;;;1303   void CAN_CLR_INT_PENDING_BIT(CAN_T *tCAN, uint8_t u32MsgNum)
000000  b570              PUSH     {r4-r6,lr}
;;;1304   {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;1305       uint32_t u32MsgIfNum;
;;;1306   
;;;1307       if((u32MsgIfNum = LockIF_TL(tCAN)) == 2ul)
000006  f7fffffe          BL       LockIF_TL
00000a  4601              MOV      r1,r0
00000c  2802              CMP      r0,#2
00000e  d100              BNE      |L3.18|
;;;1308       {
;;;1309           u32MsgIfNum = 0ul;
000010  2100              MOVS     r1,#0
                  |L3.18|
;;;1310       }
;;;1311       else
;;;1312       {
;;;1313       }
;;;1314   
;;;1315       tCAN->IF[u32MsgIfNum].CMASK = CAN_IF_CMASK_CLRINTPND_Msk | CAN_IF_CMASK_TXRQSTNEWDAT_Msk;
000012  eb010041          ADD      r0,r1,r1,LSL #1
000016  eb051040          ADD      r0,r5,r0,LSL #5
00001a  220c              MOVS     r2,#0xc
00001c  6242              STR      r2,[r0,#0x24]
00001e  1c64              ADDS     r4,r4,#1
;;;1316       tCAN->IF[u32MsgIfNum].CREQ = 1ul + u32MsgNum;
000020  6204              STR      r4,[r0,#0x20]
;;;1317   
;;;1318       ReleaseIF(tCAN, u32MsgIfNum);
000022  4628              MOV      r0,r5
000024  e8bd4070          POP      {r4-r6,lr}
000028  f7ffbffe          B.W      ReleaseIF
;;;1319   }
;;;1320   
                          ENDP


                          AREA ||i.CAN_Close||, CODE, READONLY, ALIGN=1

                  CAN_Close PROC
;;;907      */
;;;908    void CAN_Close(CAN_T *tCAN)
000000  6801              LDR      r1,[r0,#0]
000002  f021010e          BIC      r1,r1,#0xe
000006  6001              STR      r1,[r0,#0]
;;;909    {
;;;910        CAN_DisableInt(tCAN, (CAN_CON_IE_Msk | CAN_CON_SIE_Msk | CAN_CON_EIE_Msk));
;;;911    }
000008  4770              BX       lr
;;;912    
                          ENDP


                          AREA ||i.CAN_DisableInt||, CODE, READONLY, ALIGN=1

                  CAN_DisableInt PROC
;;;1087     */
;;;1088   void CAN_DisableInt(CAN_T *tCAN, uint32_t u32Mask)
000000  6802              LDR      r2,[r0,#0]
;;;1089   {
;;;1090       tCAN->CON = tCAN->CON & ~((u32Mask & (CAN_CON_IE_Msk | CAN_CON_SIE_Msk | CAN_CON_EIE_Msk)));
000002  f001010e          AND      r1,r1,#0xe
000006  438a              BICS     r2,r2,r1
000008  6002              STR      r2,[r0,#0]
;;;1091   }
00000a  4770              BX       lr
;;;1092   
                          ENDP


                          AREA ||i.CAN_EnableInt||, CODE, READONLY, ALIGN=1

                  CAN_EnableInt PROC
;;;1071     */
;;;1072   void CAN_EnableInt(CAN_T *tCAN, uint32_t u32Mask)
000000  6802              LDR      r2,[r0,#0]
;;;1073   {
;;;1074       tCAN->CON = (tCAN->CON & ~(CAN_CON_IE_Msk | CAN_CON_SIE_Msk | CAN_CON_EIE_Msk)) |
000002  f001010e          AND      r1,r1,#0xe
000006  f022020e          BIC      r2,r2,#0xe
00000a  430a              ORRS     r2,r2,r1
00000c  6002              STR      r2,[r0,#0]
;;;1075                   (u32Mask & (CAN_CON_IE_Msk | CAN_CON_SIE_Msk | CAN_CON_EIE_Msk));
;;;1076   }
00000e  4770              BX       lr
;;;1077   
                          ENDP


                          AREA ||i.CAN_EnterInitMode||, CODE, READONLY, ALIGN=1

                  CAN_EnterInitMode PROC
;;;247      */
;;;248    void CAN_EnterInitMode(CAN_T *tCAN, uint8_t u8Mask)
000000  f0410141          ORR      r1,r1,#0x41
;;;249    {
;;;250        tCAN->CON = u8Mask | (CAN_CON_INIT_Msk | CAN_CON_CCE_Msk);
000004  6001              STR      r1,[r0,#0]
;;;251    }
000006  4770              BX       lr
;;;252    
                          ENDP


                          AREA ||i.CAN_EnterTestMode||, CODE, READONLY, ALIGN=1

                  CAN_EnterTestMode PROC
;;;353      */
;;;354    void CAN_EnterTestMode(CAN_T *tCAN, uint8_t u8TestMask)
000000  6802              LDR      r2,[r0,#0]
;;;355    {
;;;356        tCAN->CON |= CAN_CON_TEST_Msk;
000002  f0420280          ORR      r2,r2,#0x80
000006  6002              STR      r2,[r0,#0]
;;;357        tCAN->TEST = u8TestMask;
000008  6141              STR      r1,[r0,#0x14]
;;;358    }
00000a  4770              BX       lr
;;;359    
                          ENDP


                          AREA ||i.CAN_GetCANBitRate||, CODE, READONLY, ALIGN=2

                  CAN_GetCANBitRate PROC
;;;317      */
;;;318    uint32_t CAN_GetCANBitRate(CAN_T *tCAN)
000000  b570              PUSH     {r4-r6,lr}
;;;319    {
000002  4604              MOV      r4,r0
;;;320        uint32_t u32Tseg1, u32Tseg2;
;;;321        uint32_t u32Bpr;
;;;322        uint32_t u32Clock = (uint32_t)0;
000004  2500              MOVS     r5,#0
;;;323    
;;;324        SystemCoreClockUpdate();
000006  f7fffffe          BL       SystemCoreClockUpdate
;;;325        if((tCAN == CAN0) || (tCAN == CAN2))
00000a  4810              LDR      r0,|L9.76|
00000c  4284              CMP      r4,r0
00000e  d002              BEQ      |L9.22|
000010  480f              LDR      r0,|L9.80|
000012  4284              CMP      r4,r0
000014  d102              BNE      |L9.28|
                  |L9.22|
;;;326        {
;;;327            u32Clock = CLK_GetPCLK0Freq();
000016  f7fffffe          BL       CLK_GetPCLK0Freq
00001a  e004              B        |L9.38|
                  |L9.28|
;;;328        }
;;;329        else if(tCAN == CAN1)
00001c  480d              LDR      r0,|L9.84|
00001e  4284              CMP      r4,r0
000020  d102              BNE      |L9.40|
;;;330        {
;;;331            u32Clock = CLK_GetPCLK1Freq();
000022  f7fffffe          BL       CLK_GetPCLK1Freq
                  |L9.38|
000026  4605              MOV      r5,r0
                  |L9.40|
;;;332        }
;;;333    
;;;334        u32Tseg1 = (tCAN->BTIME & CAN_BTIME_TSEG1_Msk) >> CAN_BTIME_TSEG1_Pos;
000028  68e0              LDR      r0,[r4,#0xc]
00002a  f3c02203          UBFX     r2,r0,#8,#4
;;;335        u32Tseg2 = (tCAN->BTIME & CAN_BTIME_TSEG2_Msk) >> CAN_BTIME_TSEG2_Pos;
00002e  68e0              LDR      r0,[r4,#0xc]
;;;336        u32Bpr   = (tCAN->BTIME & CAN_BTIME_BRP_Msk) | (tCAN->BRPE << 6ul);
000030  69a3              LDR      r3,[r4,#0x18]
000032  f3c03102          UBFX     r1,r0,#12,#3          ;335
000036  68e0              LDR      r0,[r4,#0xc]
000038  f363109f          BFI      r0,r3,#6,#26
00003c  1c40              ADDS     r0,r0,#1
;;;337    
;;;338        return (u32Clock / (u32Bpr + 1ul) / (u32Tseg1 + u32Tseg2 + 3ul));
00003e  fbb5f3f0          UDIV     r3,r5,r0
000042  1850              ADDS     r0,r2,r1
000044  1cc0              ADDS     r0,r0,#3
000046  fbb3f0f0          UDIV     r0,r3,r0
;;;339    }
00004a  bd70              POP      {r4-r6,pc}
;;;340    
                          ENDP

                  |L9.76|
                          DCD      0x400a0000
                  |L9.80|
                          DCD      0x400a2000
                  |L9.84|
                          DCD      0x400a1000

                          AREA ||i.CAN_IsNewDataReceived||, CODE, READONLY, ALIGN=1

                  CAN_IsNewDataReceived PROC
;;;381      */
;;;382    uint32_t CAN_IsNewDataReceived(CAN_T *tCAN, uint8_t u8MsgObj)
000000  2201              MOVS     r2,#1
;;;383    {
;;;384        return (u8MsgObj < 16ul ? tCAN->NDAT1 & (1ul << u8MsgObj) : tCAN->NDAT2 & (1ul << (u8MsgObj - 16ul)));
000002  2910              CMP      r1,#0x10
000004  d202              BCS      |L10.12|
000006  f8d00120          LDR      r0,[r0,#0x120]
00000a  e002              B        |L10.18|
                  |L10.12|
00000c  f8d00124          LDR      r0,[r0,#0x124]
000010  3910              SUBS     r1,r1,#0x10
                  |L10.18|
000012  408a              LSLS     r2,r2,r1
000014  4010              ANDS     r0,r0,r2
;;;385    }
000016  4770              BX       lr
;;;386    
                          ENDP


                          AREA ||i.CAN_LeaveInitMode||, CODE, READONLY, ALIGN=2

                  CAN_LeaveInitMode PROC
;;;260      */
;;;261    void CAN_LeaveInitMode(CAN_T *tCAN)
000000  4906              LDR      r1,|L11.28|
;;;262    {
;;;263        uint32_t u32TimeOutCount = SystemCoreClock; // 1 second timeout
;;;264        tCAN->CON &= (~(CAN_CON_INIT_Msk | CAN_CON_CCE_Msk));
000002  6802              LDR      r2,[r0,#0]
000004  6809              LDR      r1,[r1,#0]            ;263  ; SystemCoreClock
000006  f0220241          BIC      r2,r2,#0x41
00000a  6002              STR      r2,[r0,#0]
00000c  e002              B        |L11.20|
                  |L11.14|
;;;265        while(tCAN->CON & CAN_CON_INIT_Msk) /* Check INIT bit is released */
;;;266        {
;;;267            if(u32TimeOutCount == 0) break;
00000e  2900              CMP      r1,#0
000010  d003              BEQ      |L11.26|
000012  1e49              SUBS     r1,r1,#1
                  |L11.20|
000014  6802              LDR      r2,[r0,#0]            ;265
000016  07d2              LSLS     r2,r2,#31             ;265
000018  d1f9              BNE      |L11.14|
                  |L11.26|
;;;268            u32TimeOutCount--;
;;;269        }
;;;270    }
00001a  4770              BX       lr
;;;271    
                          ENDP

                  |L11.28|
                          DCD      SystemCoreClock

                          AREA ||i.CAN_LeaveTestMode||, CODE, READONLY, ALIGN=1

                  CAN_LeaveTestMode PROC
;;;366      */
;;;367    void CAN_LeaveTestMode(CAN_T *tCAN)
000000  6801              LDR      r1,[r0,#0]
;;;368    {
;;;369        tCAN->CON |= CAN_CON_TEST_Msk;
000002  f0410180          ORR      r1,r1,#0x80
000006  6001              STR      r1,[r0,#0]
;;;370        tCAN->TEST &= ~(CAN_TEST_LBACK_Msk | CAN_TEST_SILENT_Msk | CAN_TEST_BASIC_Msk);
000008  6941              LDR      r1,[r0,#0x14]
00000a  f021011c          BIC      r1,r1,#0x1c
00000e  6141              STR      r1,[r0,#0x14]
;;;371        tCAN->CON &= (~CAN_CON_TEST_Msk);
000010  6801              LDR      r1,[r0,#0]
000012  f0210180          BIC      r1,r1,#0x80
000016  6001              STR      r1,[r0,#0]
;;;372    }
000018  4770              BX       lr
;;;373    
                          ENDP


                          AREA ||i.CAN_Open||, CODE, READONLY, ALIGN=1

                  CAN_Open PROC
;;;925      */
;;;926    uint32_t CAN_Open(CAN_T *tCAN, uint32_t u32BaudRate, uint32_t u32Mode)
000000  b570              PUSH     {r4-r6,lr}
;;;927    {
000002  4615              MOV      r5,r2
000004  4604              MOV      r4,r0
;;;928        uint32_t u32CurrentBitRate;
;;;929    
;;;930        u32CurrentBitRate = CAN_SetBaudRate(tCAN, u32BaudRate);
000006  f7fffffe          BL       CAN_SetBaudRate
;;;931    
;;;932        if(u32Mode == CAN_BASIC_MODE)
00000a  2d01              CMP      r5,#1
00000c  d105              BNE      |L13.26|
00000e  6822              LDR      r2,[r4,#0]
;;;933        {
;;;934            CAN_EnterTestMode(tCAN, (uint8_t)CAN_TEST_BASIC_Msk);
000010  2104              MOVS     r1,#4
000012  f0420280          ORR      r2,r2,#0x80
000016  6022              STR      r2,[r4,#0]
000018  6161              STR      r1,[r4,#0x14]
                  |L13.26|
;;;935        }
;;;936        else
;;;937        {
;;;938        }
;;;939    
;;;940        return u32CurrentBitRate;
;;;941    }
00001a  bd70              POP      {r4-r6,pc}
;;;942    
                          ENDP


                          AREA ||i.CAN_ReadMsgObj||, CODE, READONLY, ALIGN=2

                  CAN_ReadMsgObj PROC
;;;692      */
;;;693    int32_t CAN_ReadMsgObj(CAN_T *tCAN, uint8_t u8MsgObj, uint8_t u8Release, STR_CANMSG_T* pCanMsg)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;694    {
000004  4607              MOV      r7,r0
;;;695        int32_t rev = 1l;
;;;696        uint32_t u32MsgIfNum;
;;;697        uint32_t u32TimeOutCount = SystemCoreClock * 2; // 2 second timeout
000006  4830              LDR      r0,|L14.200|
000008  461c              MOV      r4,r3                 ;694
00000a  4690              MOV      r8,r2                 ;694
00000c  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000e  4689              MOV      r9,r1                 ;694
000010  0045              LSLS     r5,r0,#1
000012  2601              MOVS     r6,#1                 ;695
;;;698    
;;;699        if(!CAN_IsNewDataReceived(tCAN, u8MsgObj))
000014  4638              MOV      r0,r7
000016  f7fffffe          BL       CAN_IsNewDataReceived
00001a  b1c0              CBZ      r0,|L14.78|
;;;700        {
;;;701            rev = 0; /* return FALSE */
;;;702        }
;;;703        else
;;;704        {
;;;705            /* Get and lock a free interface */
;;;706            if((u32MsgIfNum = LockIF_TL(tCAN)) == 2ul)
00001c  4638              MOV      r0,r7
00001e  f7fffffe          BL       LockIF_TL
000022  4601              MOV      r1,r0
000024  2802              CMP      r0,#2
000026  d012              BEQ      |L14.78|
;;;707            {
;;;708                rev = 0; /* return FALSE */
;;;709            }
;;;710            else
;;;711            {
;;;712                tCAN->STATUS &= (~CAN_STATUS_RXOK_Msk);
000028  6878              LDR      r0,[r7,#4]
00002a  f0200010          BIC      r0,r0,#0x10
00002e  6078              STR      r0,[r7,#4]
;;;713    
;;;714                /* read the message contents*/
;;;715                tCAN->IF[u32MsgIfNum].CMASK = CAN_IF_CMASK_MASK_Msk
000030  ea5f0008          MOVS     r0,r8
000034  d000              BEQ      |L14.56|
;;;716                                              | CAN_IF_CMASK_ARB_Msk
;;;717                                              | CAN_IF_CMASK_CONTROL_Msk
;;;718                                              | CAN_IF_CMASK_CLRINTPND_Msk
;;;719                                              | (u8Release ? CAN_IF_CMASK_TXRQSTNEWDAT_Msk : 0ul)
000036  2004              MOVS     r0,#4
                  |L14.56|
000038  f040027b          ORR      r2,r0,#0x7b
00003c  eb010041          ADD      r0,r1,r1,LSL #1
000040  eb071040          ADD      r0,r7,r0,LSL #5
000044  6242              STR      r2,[r0,#0x24]
;;;720                                              | CAN_IF_CMASK_DATAA_Msk
;;;721                                              | CAN_IF_CMASK_DATAB_Msk;
;;;722    
;;;723                tCAN->IF[u32MsgIfNum].CREQ = 1ul + u8MsgObj;
000046  f1090201          ADD      r2,r9,#1
00004a  6202              STR      r2,[r0,#0x20]
;;;724    
;;;725                while(tCAN->IF[u32MsgIfNum].CREQ & CAN_IF_CREQ_BUSY_Msk) /*Wait*/
00004c  e003              B        |L14.86|
                  |L14.78|
00004e  2600              MOVS     r6,#0                 ;708
000050  e038              B        |L14.196|
                  |L14.82|
;;;726                {
;;;727                    if(u32TimeOutCount == 0)
000052  b165              CBZ      r5,|L14.110|
000054  1e6d              SUBS     r5,r5,#1
                  |L14.86|
000056  6a02              LDR      r2,[r0,#0x20]         ;725
000058  0412              LSLS     r2,r2,#16             ;725
00005a  d4fa              BMI      |L14.82|
;;;728                    {
;;;729                        ReleaseIF(tCAN, u32MsgIfNum);
;;;730                        return -1;
;;;731                    }
;;;732                    u32TimeOutCount--;
;;;733                }
;;;734    
;;;735                if((tCAN->IF[u32MsgIfNum].ARB2 & CAN_IF_ARB2_XTD_Msk) == 0ul)
00005c  6b42              LDR      r2,[r0,#0x34]
00005e  0452              LSLS     r2,r2,#17
000060  d40c              BMI      |L14.124|
;;;736                {
;;;737                    /* standard ID*/
;;;738                    pCanMsg->IdType = CAN_STD_ID;
000062  2200              MOVS     r2,#0
;;;739                    pCanMsg->Id     = (tCAN->IF[u32MsgIfNum].ARB2 & CAN_IF_ARB2_ID_Msk) >> 2ul;
000064  6022              STR      r2,[r4,#0]
000066  6b42              LDR      r2,[r0,#0x34]
000068  f3c2028a          UBFX     r2,r2,#2,#11
00006c  e00e              B        |L14.140|
                  |L14.110|
00006e  4638              MOV      r0,r7                 ;729
000070  f7fffffe          BL       ReleaseIF
000074  f04f30ff          MOV      r0,#0xffffffff        ;730
                  |L14.120|
;;;740                }
;;;741                else
;;;742                {
;;;743                    /* extended ID*/
;;;744                    pCanMsg->IdType = CAN_EXT_ID;
;;;745                    pCanMsg->Id  = (((tCAN->IF[u32MsgIfNum].ARB2) & 0x1FFFul) << 16) | tCAN->IF[u32MsgIfNum].ARB1;
;;;746                }
;;;747    
;;;748                pCanMsg->DLC     = (uint8_t)(tCAN->IF[u32MsgIfNum].MCON & CAN_IF_MCON_DLC_Msk);
;;;749                pCanMsg->Data[0] = (uint8_t)(tCAN->IF[u32MsgIfNum].DAT_A1 & CAN_IF_DAT_A1_DATA0_Msk);
;;;750                pCanMsg->Data[1] = (uint8_t)((tCAN->IF[u32MsgIfNum].DAT_A1 & CAN_IF_DAT_A1_DATA1_Msk) >> CAN_IF_DAT_A1_DATA1_Pos);
;;;751                pCanMsg->Data[2] = (uint8_t)(tCAN->IF[u32MsgIfNum].DAT_A2 & CAN_IF_DAT_A2_DATA2_Msk);
;;;752                pCanMsg->Data[3] = (uint8_t)((tCAN->IF[u32MsgIfNum].DAT_A2 & CAN_IF_DAT_A2_DATA3_Msk) >> CAN_IF_DAT_A2_DATA3_Pos);
;;;753                pCanMsg->Data[4] = (uint8_t)(tCAN->IF[u32MsgIfNum].DAT_B1 & CAN_IF_DAT_B1_DATA4_Msk);
;;;754                pCanMsg->Data[5] = (uint8_t)((tCAN->IF[u32MsgIfNum].DAT_B1 & CAN_IF_DAT_B1_DATA5_Msk) >> CAN_IF_DAT_B1_DATA5_Pos);
;;;755                pCanMsg->Data[6] = (uint8_t)(tCAN->IF[u32MsgIfNum].DAT_B2 & CAN_IF_DAT_B2_DATA6_Msk);
;;;756                pCanMsg->Data[7] = (uint8_t)((tCAN->IF[u32MsgIfNum].DAT_B2 & CAN_IF_DAT_B2_DATA7_Msk) >> CAN_IF_DAT_B2_DATA7_Pos);
;;;757    
;;;758                ReleaseIF(tCAN, u32MsgIfNum);
;;;759            }
;;;760        }
;;;761    
;;;762        return rev;
;;;763    }
000078  e8bd87f0          POP      {r4-r10,pc}
                  |L14.124|
00007c  2201              MOVS     r2,#1                 ;744
00007e  6022              STR      r2,[r4,#0]            ;745
000080  6b02              LDR      r2,[r0,#0x30]         ;745
000082  6b43              LDR      r3,[r0,#0x34]         ;745
000084  f3c3030c          UBFX     r3,r3,#0,#13          ;745
000088  ea424203          ORR      r2,r2,r3,LSL #16      ;745
                  |L14.140|
00008c  60a2              STR      r2,[r4,#8]            ;748
00008e  6b82              LDR      r2,[r0,#0x38]         ;748
000090  f002020f          AND      r2,r2,#0xf            ;748
000094  7322              STRB     r2,[r4,#0xc]          ;748
000096  6bc2              LDR      r2,[r0,#0x3c]         ;749
000098  7362              STRB     r2,[r4,#0xd]          ;749
00009a  6bc2              LDR      r2,[r0,#0x3c]         ;750
00009c  0a12              LSRS     r2,r2,#8              ;750
00009e  73a2              STRB     r2,[r4,#0xe]          ;750
0000a0  6c02              LDR      r2,[r0,#0x40]         ;751
0000a2  73e2              STRB     r2,[r4,#0xf]          ;751
0000a4  6c02              LDR      r2,[r0,#0x40]         ;752
0000a6  0a12              LSRS     r2,r2,#8              ;752
0000a8  7422              STRB     r2,[r4,#0x10]         ;752
0000aa  6c42              LDR      r2,[r0,#0x44]         ;753
0000ac  7462              STRB     r2,[r4,#0x11]         ;753
0000ae  6c42              LDR      r2,[r0,#0x44]         ;754
0000b0  0a12              LSRS     r2,r2,#8              ;754
0000b2  74a2              STRB     r2,[r4,#0x12]         ;754
0000b4  6c82              LDR      r2,[r0,#0x48]         ;755
0000b6  74e2              STRB     r2,[r4,#0x13]         ;755
0000b8  6c80              LDR      r0,[r0,#0x48]         ;756
0000ba  0a00              LSRS     r0,r0,#8              ;756
0000bc  7520              STRB     r0,[r4,#0x14]         ;756
0000be  4638              MOV      r0,r7                 ;758
0000c0  f7fffffe          BL       ReleaseIF
                  |L14.196|
0000c4  4630              MOV      r0,r6                 ;762
0000c6  e7d7              B        |L14.120|
;;;764    
                          ENDP

                  |L14.200|
                          DCD      SystemCoreClock

                          AREA ||i.CAN_Receive||, CODE, READONLY, ALIGN=1

                  CAN_Receive PROC
;;;1274     */
;;;1275   int32_t CAN_Receive(CAN_T *tCAN, uint32_t u32MsgNum, STR_CANMSG_T* pCanMsg)
000000  b430              PUSH     {r4,r5}
;;;1276   {
000002  460c              MOV      r4,r1
;;;1277       int32_t rev = (int32_t)TRUE;
;;;1278       uint32_t u32Tmp;
;;;1279   
;;;1280       u32Tmp = (tCAN->TEST & CAN_TEST_BASIC_Msk);
000004  6941              LDR      r1,[r0,#0x14]
;;;1281   
;;;1282       if((tCAN->CON & CAN_CON_TEST_Msk) && u32Tmp)
000006  6803              LDR      r3,[r0,#0]
000008  f0010104          AND      r1,r1,#4              ;1280
00000c  061b              LSLS     r3,r3,#24
00000e  d504              BPL      |L15.26|
000010  b119              CBZ      r1,|L15.26|
;;;1283       {
;;;1284           rev = CAN_BasicReceiveMsg(tCAN, pCanMsg);
000012  bc30              POP      {r4,r5}
000014  4611              MOV      r1,r2
000016  f7ffbffe          B.W      CAN_BasicReceiveMsg
                  |L15.26|
;;;1285       }
;;;1286       else
;;;1287       {
;;;1288           rev = CAN_ReadMsgObj(tCAN, (uint8_t)u32MsgNum, (uint8_t)TRUE, pCanMsg);
00001a  b2e1              UXTB     r1,r4
00001c  4613              MOV      r3,r2
00001e  bc30              POP      {r4,r5}
000020  2201              MOVS     r2,#1
000022  f7ffbffe          B.W      CAN_ReadMsgObj
;;;1289       }
;;;1290   
;;;1291       return rev;
;;;1292   }
;;;1293   
                          ENDP


                          AREA ||i.CAN_SetBaudRate||, CODE, READONLY, ALIGN=2

                  CAN_SetBaudRate PROC
;;;775      */
;;;776    uint32_t CAN_SetBaudRate(CAN_T *tCAN, uint32_t u32BaudRate)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;777    {
000004  b089              SUB      sp,sp,#0x24
000006  4680              MOV      r8,r0
;;;778        long rate;
;;;779        long best_error = 1000000000, error = 0;
000008  485c              LDR      r0,|L16.380|
;;;780        int best_tseg = 0, best_brp = 0, brp = 0;
00000a  9007              STR      r0,[sp,#0x1c]
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
;;;781        int tsegall, tseg = 0, tseg1 = 0, tseg2 = 0;
000010  9004              STR      r0,[sp,#0x10]
000012  9002              STR      r0,[sp,#8]
;;;782        int spt_error = 1000, spt = 0, sampl_pt;
000014  9003              STR      r0,[sp,#0xc]
000016  460e              MOV      r6,r1                 ;777
000018  f44f707a          MOV      r0,#0x3e8
00001c  2401              MOVS     r4,#1
00001e  2141              MOVS     r1,#0x41
000020  9006              STR      r0,[sp,#0x18]
000022  2500              MOVS     r5,#0
;;;783        uint64_t clock_freq = (uint64_t)0, u64PCLK_DIV = (uint64_t)1;
;;;784        uint32_t sjw = (uint32_t)1;
000024  4627              MOV      r7,r4
000026  f8c81000          STR      r1,[r8,#0]
;;;785    
;;;786        CAN_EnterInitMode(tCAN, (uint8_t)0);
;;;787    
;;;788        SystemCoreClockUpdate();
00002a  f7fffffe          BL       SystemCoreClockUpdate
;;;789        if((tCAN == CAN0) || (tCAN == CAN2))
00002e  4a54              LDR      r2,|L16.384|
000030  f04f0901          MOV      r9,#1                 ;784
;;;790        {
;;;791            u64PCLK_DIV = (uint64_t)(CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk);
000034  0350              LSLS     r0,r2,#13
000036  4590              CMP      r8,r2                 ;789
000038  d002              BEQ      |L16.64|
00003a  4a52              LDR      r2,|L16.388|
00003c  4590              CMP      r8,r2                 ;789
00003e  d104              BNE      |L16.74|
                  |L16.64|
000040  f8d00234          LDR      r0,[r0,#0x234]
000044  f0000007          AND      r0,r0,#7
;;;792            u64PCLK_DIV = (uint64_t)(1 << u64PCLK_DIV);
000048  e006              B        |L16.88|
                  |L16.74|
;;;793        }
;;;794        else if(tCAN == CAN1)
00004a  4a4f              LDR      r2,|L16.392|
00004c  4590              CMP      r8,r2
00004e  d106              BNE      |L16.94|
;;;795        {
;;;796            u64PCLK_DIV = (uint64_t)((CLK->PCLKDIV & CLK_PCLKDIV_APB1DIV_Msk) >> CLK_PCLKDIV_APB1DIV_Pos);
000050  f8d00234          LDR      r0,[r0,#0x234]
000054  f3c01002          UBFX     r0,r0,#4,#3
                  |L16.88|
;;;797            u64PCLK_DIV = (uint64_t)(1 << u64PCLK_DIV);
000058  fa09f400          LSL      r4,r9,r0
00005c  17e5              ASRS     r5,r4,#31
                  |L16.94|
;;;798        }
;;;799    
;;;800        clock_freq = SystemCoreClock / u64PCLK_DIV;
00005e  484b              LDR      r0,|L16.396|
000060  4622              MOV      r2,r4
000062  462b              MOV      r3,r5
000064  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000066  2100              MOVS     r1,#0
000068  f7fffffe          BL       __aeabi_uldivmod
00006c  4682              MOV      r10,r0
;;;801    
;;;802        if(u32BaudRate >= (uint32_t)1000000)
00006e  4848              LDR      r0,|L16.400|
000070  468b              MOV      r11,r1                ;800
000072  4286              CMP      r6,r0
000074  d301              BCC      |L16.122|
;;;803        {
;;;804            u32BaudRate = (uint32_t)1000000;
000076  4606              MOV      r6,r0
000078  e002              B        |L16.128|
                  |L16.122|
;;;805        }
;;;806    
;;;807        /* Use CIA recommended sample points */
;;;808        if (u32BaudRate > (uint32_t)800000)
00007a  4846              LDR      r0,|L16.404|
00007c  4286              CMP      r6,r0
00007e  d902              BLS      |L16.134|
                  |L16.128|
;;;809        {
;;;810            sampl_pt = (int)750;
000080  f24020ee          MOV      r0,#0x2ee
000084  e007              B        |L16.150|
                  |L16.134|
;;;811        }
;;;812        else if (u32BaudRate > (uint32_t)500000)
000086  4844              LDR      r0,|L16.408|
000088  4286              CMP      r6,r0
00008a  d902              BLS      |L16.146|
;;;813        {
;;;814            sampl_pt = (int)800;
00008c  f44f7048          MOV      r0,#0x320
000090  e001              B        |L16.150|
                  |L16.146|
;;;815        }
;;;816        else
;;;817        {
;;;818            sampl_pt = (int)875;
000092  f240306b          MOV      r0,#0x36b
                  |L16.150|
;;;819        }
;;;820    
;;;821        /* tseg even = round down, odd = round up */
;;;822        for (tseg = (TSEG1_MAX + TSEG2_MAX) * 2ul + 1ul; tseg >= (TSEG1_MIN + TSEG2_MIN) * 2ul; tseg--)
000096  2431              MOVS     r4,#0x31
000098  9001              STR      r0,[sp,#4]
                  |L16.154|
;;;823        {
;;;824            tsegall = 1ul + tseg / 2ul;
00009a  2001              MOVS     r0,#1
00009c  eb000954          ADD      r9,r0,r4,LSR #1
;;;825            /* Compute all possible tseg choices (tseg=tseg1+tseg2) */
;;;826            brp = clock_freq / (tsegall * u32BaudRate) + tseg % 2;
0000a0  fb09f206          MUL      r2,r9,r6
0000a4  2300              MOVS     r3,#0
0000a6  4650              MOV      r0,r10
0000a8  4659              MOV      r1,r11
0000aa  f7fffffe          BL       __aeabi_uldivmod
0000ae  eb0471d4          ADD      r1,r4,r4,LSR #31
0000b2  9105              STR      r1,[sp,#0x14]
0000b4  f0210101          BIC      r1,r1,#1
0000b8  1a61              SUBS     r1,r4,r1
0000ba  1845              ADDS     r5,r0,r1
;;;827            /* chose brp step which is possible in system */
;;;828            brp = (brp / BRP_INC) * BRP_INC;
;;;829    
;;;830            if ((brp < BRP_MIN) || (brp > BRP_MAX))
0000bc  f1a50001          SUB      r0,r5,#1
0000c0  f5b06f80          CMP      r0,#0x400
0000c4  d222              BCS      |L16.268|
;;;831            {
;;;832                continue;
;;;833            }
;;;834            rate = clock_freq / (brp * tsegall);
0000c6  fb05f209          MUL      r2,r5,r9
0000ca  17d3              ASRS     r3,r2,#31
0000cc  4650              MOV      r0,r10
0000ce  4659              MOV      r1,r11
0000d0  f7fffffe          BL       __aeabi_uldivmod
;;;835    
;;;836            error = u32BaudRate - rate;
0000d4  1a30              SUBS     r0,r6,r0
;;;837    
;;;838            /* tseg brp biterror */
;;;839            if (error < 0)
0000d6  d500              BPL      |L16.218|
;;;840            {
;;;841                error = -error;
0000d8  4240              RSBS     r0,r0,#0
                  |L16.218|
;;;842            }
;;;843            if (error > best_error)
0000da  9907              LDR      r1,[sp,#0x1c]
0000dc  4288              CMP      r0,r1
0000de  dc15              BGT      |L16.268|
;;;844            {
;;;845                continue;
;;;846            }
;;;847            best_error = error;
;;;848            if (error == 0)
0000e0  9007              STR      r0,[sp,#0x1c]
0000e2  b970              CBNZ     r0,|L16.258|
;;;849            {
;;;850                spt = can_update_spt(sampl_pt, tseg / 2, &tseg1, &tseg2);
0000e4  9805              LDR      r0,[sp,#0x14]
0000e6  ab03              ADD      r3,sp,#0xc
0000e8  1041              ASRS     r1,r0,#1
0000ea  aa02              ADD      r2,sp,#8
0000ec  9801              LDR      r0,[sp,#4]
0000ee  f7fffffe          BL       can_update_spt
;;;851                error = sampl_pt - spt;
0000f2  9901              LDR      r1,[sp,#4]
0000f4  1a08              SUBS     r0,r1,r0
;;;852                if (error < 0)
0000f6  d500              BPL      |L16.250|
;;;853                {
;;;854                    error = -error;
0000f8  4240              RSBS     r0,r0,#0
                  |L16.250|
;;;855                }
;;;856                if (error > spt_error)
0000fa  9906              LDR      r1,[sp,#0x18]
0000fc  4288              CMP      r0,r1
0000fe  dc05              BGT      |L16.268|
;;;857                {
;;;858                    continue;
;;;859                }
;;;860                spt_error = error;
000100  9006              STR      r0,[sp,#0x18]
                  |L16.258|
;;;861            }
;;;862            best_tseg = tseg / 2;
000102  9905              LDR      r1,[sp,#0x14]
;;;863            best_brp = brp;
;;;864    
;;;865            if (error == 0)
000104  9504              STR      r5,[sp,#0x10]
000106  1049              ASRS     r1,r1,#1              ;862
000108  9100              STR      r1,[sp,#0]
00010a  b110              CBZ      r0,|L16.274|
                  |L16.268|
00010c  1e64              SUBS     r4,r4,#1
00010e  2c06              CMP      r4,#6                 ;822
000110  d2c3              BCS      |L16.154|
                  |L16.274|
;;;866            {
;;;867                break;
;;;868            }
;;;869        }
;;;870    
;;;871        spt = can_update_spt(sampl_pt, best_tseg, &tseg1, &tseg2);
000112  e9dd1000          LDRD     r1,r0,[sp,#0]
000116  ab03              ADD      r3,sp,#0xc
000118  aa02              ADD      r2,sp,#8
00011a  f7fffffe          BL       can_update_spt
;;;872    
;;;873        /* check for sjw user settings */
;;;874        /* bt->sjw is at least 1 -> sanitize upper bound to sjw_max */
;;;875        if (sjw > SJW_MAX)
00011e  2f04              CMP      r7,#4
000120  d900              BLS      |L16.292|
;;;876        {
;;;877            sjw = SJW_MAX;
000122  2704              MOVS     r7,#4
                  |L16.292|
;;;878        }
;;;879        /* bt->sjw must not be higher than tseg2 */
;;;880        if (tseg2 < sjw)
000124  9c03              LDR      r4,[sp,#0xc]
000126  42bc              CMP      r4,r7
000128  d200              BCS      |L16.300|
;;;881        {
;;;882            sjw = tseg2;
00012a  4627              MOV      r7,r4
                  |L16.300|
;;;883        }
;;;884    
;;;885        /* real bit-rate */
;;;886        u32BaudRate = clock_freq / (best_brp * (tseg1 + tseg2 + 1));
00012c  9d02              LDR      r5,[sp,#8]
00012e  9804              LDR      r0,[sp,#0x10]
000130  192a              ADDS     r2,r5,r4
000132  1c52              ADDS     r2,r2,#1
000134  4342              MULS     r2,r0,r2
000136  17d3              ASRS     r3,r2,#31
000138  4650              MOV      r0,r10
00013a  4659              MOV      r1,r11
00013c  f7fffffe          BL       __aeabi_uldivmod
000140  4603              MOV      r3,r0
;;;887    
;;;888        tCAN->BTIME = ((uint32_t)(tseg2 - 1ul) << CAN_BTIME_TSEG2_Pos) | ((uint32_t)(tseg1 - 1ul) << CAN_BTIME_TSEG1_Pos) |
000142  0320              LSLS     r0,r4,#12
000144  f06f01ff          MVN      r1,#0xff
000148  eb012105          ADD      r1,r1,r5,LSL #8
00014c  f5a05080          SUB      r0,r0,#0x1000
000150  4308              ORRS     r0,r0,r1
000152  9904              LDR      r1,[sp,#0x10]
000154  1e49              SUBS     r1,r1,#1
000156  f001023f          AND      r2,r1,#0x3f
00015a  4310              ORRS     r0,r0,r2
00015c  ea401287          ORR      r2,r0,r7,LSL #6
000160  4640              MOV      r0,r8
000162  f8c8200c          STR      r2,[r8,#0xc]
;;;889                      ((uint32_t)(best_brp - 1ul) & CAN_BTIME_BRP_Msk) | (sjw << CAN_BTIME_SJW_Pos);
;;;890        tCAN->BRPE  = ((uint32_t)(best_brp - 1ul) >> 6) & 0x0Ful;
000166  f3c11183          UBFX     r1,r1,#6,#4
00016a  f8c81018          STR      r1,[r8,#0x18]
;;;891    
;;;892        /* printf("\n bitrate = %d \n", CAN_GetCANBitRate(tCAN)); */
;;;893    
;;;894        CAN_LeaveInitMode(tCAN);
00016e  f7fffffe          BL       CAN_LeaveInitMode
;;;895    
;;;896        return u32BaudRate;
;;;897    }
000172  b009              ADD      sp,sp,#0x24
000174  4618              MOV      r0,r3                 ;896
000176  e8bd8ff0          POP      {r4-r11,pc}
;;;898    
                          ENDP

00017a  0000              DCW      0x0000
                  |L16.380|
                          DCD      0x3b9aca00
                  |L16.384|
                          DCD      0x400a0000
                  |L16.388|
                          DCD      0x400a2000
                  |L16.392|
                          DCD      0x400a1000
                  |L16.396|
                          DCD      SystemCoreClock
                  |L16.400|
                          DCD      0x000f4240
                  |L16.404|
                          DCD      0x000c3500
                  |L16.408|
                          DCD      0x0007a120

                          AREA ||i.CAN_SetMultiRxMsg||, CODE, READONLY, ALIGN=1

                  CAN_SetMultiRxMsg PROC
;;;1183     */
;;;1184   int32_t CAN_SetMultiRxMsg(CAN_T *tCAN, uint32_t u32MsgNum, uint32_t u32MsgCount, uint32_t u32IDType, uint32_t u32ID)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1185   {
;;;1186       int32_t  rev = (int32_t)TRUE;
000004  f04f0a01          MOV      r10,#1
000008  b081              SUB      sp,sp,#4              ;1185
00000a  469b              MOV      r11,r3                ;1185
00000c  460e              MOV      r6,r1                 ;1185
;;;1187       uint32_t i = 0ul;
;;;1188       uint32_t u32TimeOutCount;
;;;1189       uint32_t u32EOB_Flag = 0ul;
00000e  f04f0800          MOV      r8,#0
;;;1190   
;;;1191       for(i = 1ul; i < u32MsgCount; i++)
000012  4654              MOV      r4,r10
;;;1192       {
;;;1193           u32TimeOutCount = 0ul;
;;;1194   
;;;1195           u32MsgNum += (i - 1ul);
;;;1196   
;;;1197           if(i == u32MsgCount)
;;;1198           {
;;;1199               u32EOB_Flag = 1ul;
;;;1200           }
;;;1201           else
;;;1202           {
;;;1203           }
;;;1204   
;;;1205           while(CAN_SetRxMsgObj(tCAN, (uint8_t)u32MsgNum, (uint8_t)u32IDType, u32ID, (uint8_t)u32EOB_Flag) == (int32_t)FALSE)
;;;1206           {
;;;1207               if(++u32TimeOutCount >= RETRY_COUNTS)
000014  f04f5980          MOV      r9,#0x10000000
000018  e013              B        |L17.66|
                  |L17.26|
00001a  4426              ADD      r6,r6,r4              ;1195
00001c  f04f0500          MOV      r5,#0                 ;1193
000020  f1a60601          SUB      r6,r6,#1              ;1195
000024  d101              BNE      |L17.42|
000026  f04f0801          MOV      r8,#1                 ;1199
                  |L17.42|
00002a  f00807ff          AND      r7,r8,#0xff           ;1205
                  |L17.46|
00002e  f00b02ff          AND      r2,r11,#0xff          ;1205
000032  b2f1              UXTB     r1,r6                 ;1205
000034  9700              STR      r7,[sp,#0]            ;1205
000036  9b0e              LDR      r3,[sp,#0x38]         ;1205
000038  9801              LDR      r0,[sp,#4]            ;1205
00003a  f7fffffe          BL       CAN_SetRxMsgObj
00003e  b138              CBZ      r0,|L17.80|
                  |L17.64|
000040  1c64              ADDS     r4,r4,#1              ;1205
                  |L17.66|
000042  9803              LDR      r0,[sp,#0xc]          ;1191
000044  4284              CMP      r4,r0                 ;1191
000046  d3e8              BCC      |L17.26|
;;;1208               {
;;;1209                   rev = (int32_t)FALSE;
;;;1210                   break;
;;;1211               }
;;;1212               else
;;;1213               {
;;;1214               }
;;;1215           }
;;;1216       }
;;;1217   
;;;1218       return rev;
;;;1219   }
000048  b005              ADD      sp,sp,#0x14
00004a  4650              MOV      r0,r10                ;1218
00004c  e8bd8ff0          POP      {r4-r11,pc}
                  |L17.80|
000050  f1050501          ADD      r5,r5,#1
000054  454d              CMP      r5,r9                 ;1207
000056  d3ea              BCC      |L17.46|
000058  f04f0a00          MOV      r10,#0                ;1209
00005c  e7f0              B        |L17.64|
;;;1220   
                          ENDP


                          AREA ||i.CAN_SetRxMsg||, CODE, READONLY, ALIGN=1

                  CAN_SetRxMsg PROC
;;;1109     */
;;;1110   int32_t CAN_SetRxMsg(CAN_T *tCAN, uint32_t u32MsgNum, uint32_t u32IDType, uint32_t u32ID)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1111   {
;;;1112       int32_t rev = (int32_t)TRUE;
000004  2501              MOVS     r5,#1
000006  469a              MOV      r10,r3                ;1111
000008  4616              MOV      r6,r2                 ;1111
00000a  460f              MOV      r7,r1                 ;1111
00000c  4683              MOV      r11,r0                ;1111
;;;1113       uint32_t u32TimeOutCount = 0ul;
00000e  2400              MOVS     r4,#0
;;;1114   
;;;1115       while(CAN_SetRxMsgObj(tCAN, (uint8_t)u32MsgNum, (uint8_t)u32IDType, u32ID, (uint8_t)TRUE) == (int32_t)FALSE)
;;;1116       {
;;;1117           if(++u32TimeOutCount >= RETRY_COUNTS)
000010  f04f5980          MOV      r9,#0x10000000
000014  46a8              MOV      r8,r5                 ;1112
000016  e004              B        |L18.34|
                  |L18.24|
000018  1c64              ADDS     r4,r4,#1              ;1111
00001a  454c              CMP      r4,r9
00001c  d301              BCC      |L18.34|
;;;1118           {
;;;1119               rev = (int32_t)(FALSE); /* return FALSE */
00001e  2500              MOVS     r5,#0
;;;1120               break;
000020  e009              B        |L18.54|
                  |L18.34|
000022  b2f2              UXTB     r2,r6                 ;1115
000024  b2f9              UXTB     r1,r7                 ;1115
000026  4653              MOV      r3,r10                ;1115
000028  4658              MOV      r0,r11                ;1115
00002a  f8cd8000          STR      r8,[sp,#0]            ;1115
00002e  f7fffffe          BL       CAN_SetRxMsgObj
000032  2800              CMP      r0,#0                 ;1115
000034  d0f0              BEQ      |L18.24|
                  |L18.54|
;;;1121           }
;;;1122           else
;;;1123           {
;;;1124           }
;;;1125       }
;;;1126   
;;;1127       return rev;
000036  4628              MOV      r0,r5
;;;1128   }
000038  e8bd8ff8          POP      {r3-r11,pc}
;;;1129   
                          ENDP


                          AREA ||i.CAN_SetRxMsgAndMsk||, CODE, READONLY, ALIGN=1

                  CAN_SetRxMsgAndMsk PROC
;;;1146     */
;;;1147   int32_t CAN_SetRxMsgAndMsk(CAN_T *tCAN, uint32_t u32MsgNum, uint32_t u32IDType, uint32_t u32ID, uint32_t u32IDMask)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1148   {
000004  b083              SUB      sp,sp,#0xc
;;;1149       int32_t  rev = (int32_t)TRUE;
000006  2501              MOVS     r5,#1
000008  469b              MOV      r11,r3                ;1148
00000a  4616              MOV      r6,r2                 ;1148
00000c  460f              MOV      r7,r1                 ;1148
;;;1150       uint32_t u32TimeOutCount = 0ul;
00000e  2400              MOVS     r4,#0
;;;1151   
;;;1152       while(CAN_SetRxMsgObjAndMsk(tCAN, (uint8_t)u32MsgNum, (uint8_t)u32IDType, u32ID, u32IDMask, (uint8_t)TRUE) == (int32_t)FALSE)
;;;1153       {
;;;1154           if(++u32TimeOutCount >= RETRY_COUNTS)
000010  f04f5a80          MOV      r10,#0x10000000
000014  46a9              MOV      r9,r5                 ;1149
000016  f8dd8040          LDR      r8,[sp,#0x40]         ;1148
00001a  e004              B        |L19.38|
                  |L19.28|
00001c  1c64              ADDS     r4,r4,#1              ;1148
00001e  4554              CMP      r4,r10
000020  d301              BCC      |L19.38|
;;;1155           {
;;;1156               rev = (int32_t)FALSE;
000022  2500              MOVS     r5,#0
;;;1157               break;
000024  e009              B        |L19.58|
                  |L19.38|
000026  b2f2              UXTB     r2,r6                 ;1152
000028  b2f9              UXTB     r1,r7                 ;1152
00002a  465b              MOV      r3,r11                ;1152
00002c  e9cd8900          STRD     r8,r9,[sp,#0]         ;1152
000030  9803              LDR      r0,[sp,#0xc]          ;1152
000032  f7fffffe          BL       CAN_SetRxMsgObjAndMsk
000036  2800              CMP      r0,#0                 ;1152
000038  d0f0              BEQ      |L19.28|
                  |L19.58|
;;;1158           }
;;;1159           else
;;;1160           {
;;;1161           }
;;;1162       }
;;;1163   
;;;1164       return rev;
;;;1165   }
00003a  b007              ADD      sp,sp,#0x1c
00003c  4628              MOV      r0,r5                 ;1164
00003e  e8bd8ff0          POP      {r4-r11,pc}
;;;1166   
                          ENDP


                          AREA ||i.CAN_SetRxMsgObj||, CODE, READONLY, ALIGN=1

                  CAN_SetRxMsgObj PROC
;;;628      */
;;;629    int32_t CAN_SetRxMsgObj(CAN_T *tCAN, uint8_t u8MsgObj, uint8_t u8idType, uint32_t u32id, uint8_t u8singleOrFifoLast)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;630    {
000004  461c              MOV      r4,r3
000006  4617              MOV      r7,r2
000008  460e              MOV      r6,r1
00000a  4680              MOV      r8,r0
;;;631        int32_t rev = 1l;
00000c  2501              MOVS     r5,#1
;;;632        uint32_t u32MsgIfNum;
;;;633    
;;;634        /* Get and lock a free interface */
;;;635        if((u32MsgIfNum = LockIF_TL(tCAN)) == 2ul)
00000e  f8dd9020          LDR      r9,[sp,#0x20]
000012  f7fffffe          BL       LockIF_TL
000016  4601              MOV      r1,r0
000018  2802              CMP      r0,#2
00001a  d018              BEQ      |L20.78|
;;;636        {
;;;637            rev = 0; /* return FALSE */
;;;638        }
;;;639        else
;;;640        {
;;;641            /* Command Setting */
;;;642            tCAN->IF[u32MsgIfNum].CMASK = CAN_IF_CMASK_WRRD_Msk | CAN_IF_CMASK_MASK_Msk | CAN_IF_CMASK_ARB_Msk |
00001c  eb010341          ADD      r3,r1,r1,LSL #1
000020  eb081043          ADD      r0,r8,r3,LSL #5
000024  22f3              MOVS     r2,#0xf3
000026  6242              STR      r2,[r0,#0x24]
000028  2200              MOVS     r2,#0
;;;643                                          CAN_IF_CMASK_CONTROL_Msk | CAN_IF_CMASK_DATAA_Msk | CAN_IF_CMASK_DATAB_Msk;
;;;644    
;;;645            if(u8idType == CAN_STD_ID)    /* According STD/EXT ID format,Configure Mask and Arbitration register */
00002a  b197              CBZ      r7,|L20.82|
;;;646            {
;;;647                tCAN->IF[u32MsgIfNum].ARB1 = 0ul;
;;;648                tCAN->IF[u32MsgIfNum].ARB2 = CAN_IF_ARB2_MSGVAL_Msk | (u32id & 0x7FFul) << 2;
;;;649            }
;;;650            else
;;;651            {
;;;652                tCAN->IF[u32MsgIfNum].ARB1 = u32id & 0xFFFFul;
00002c  b2a3              UXTH     r3,r4
00002e  6303              STR      r3,[r0,#0x30]
;;;653                tCAN->IF[u32MsgIfNum].ARB2 = CAN_IF_ARB2_MSGVAL_Msk | CAN_IF_ARB2_XTD_Msk | (u32id & 0x1FFF0000ul) >> 16;
000030  f3c4430c          UBFX     r3,r4,#16,#13
000034  f4434340          ORR      r3,r3,#0xc000
                  |L20.56|
000038  6343              STR      r3,[r0,#0x34]
;;;654            }
;;;655    
;;;656            /* tCAN->IF[u8MsgIfNum].MCON |= CAN_IF_MCON_UMASK_Msk | CAN_IF_MCON_RXIE_Msk; */
;;;657            tCAN->IF[u32MsgIfNum].MCON = CAN_IF_MCON_UMASK_Msk | CAN_IF_MCON_RXIE_Msk;
00003a  f44f53a0          MOV      r3,#0x1400
00003e  6383              STR      r3,[r0,#0x38]
;;;658            if(u8singleOrFifoLast)
;;;659            {
;;;660                tCAN->IF[u32MsgIfNum].MCON |= CAN_IF_MCON_EOB_Msk;
;;;661            }
;;;662            else
;;;663            {
;;;664                tCAN->IF[u32MsgIfNum].MCON &= (~CAN_IF_MCON_EOB_Msk);
000040  6b83              LDR      r3,[r0,#0x38]
000042  f1b90f00          CMP      r9,#0                 ;658
000046  d00c              BEQ      |L20.98|
000048  f0430380          ORR      r3,r3,#0x80           ;660
00004c  e00b              B        |L20.102|
                  |L20.78|
00004e  2500              MOVS     r5,#0                 ;637
000050  e013              B        |L20.122|
                  |L20.82|
000052  6302              STR      r2,[r0,#0x30]         ;647
000054  f3c4030a          UBFX     r3,r4,#0,#11          ;648
000058  f44f4400          MOV      r4,#0x8000            ;648
00005c  ea440383          ORR      r3,r4,r3,LSL #2       ;648
000060  e7ea              B        |L20.56|
                  |L20.98|
000062  f0230380          BIC      r3,r3,#0x80
                  |L20.102|
000066  6383              STR      r3,[r0,#0x38]
;;;665            }
;;;666    
;;;667            tCAN->IF[u32MsgIfNum].DAT_A1  = 0ul;
000068  63c2              STR      r2,[r0,#0x3c]
;;;668            tCAN->IF[u32MsgIfNum].DAT_A2  = 0ul;
00006a  6402              STR      r2,[r0,#0x40]
;;;669            tCAN->IF[u32MsgIfNum].DAT_B1  = 0ul;
00006c  6442              STR      r2,[r0,#0x44]
;;;670            tCAN->IF[u32MsgIfNum].DAT_B2  = 0ul;
00006e  6482              STR      r2,[r0,#0x48]
000070  1c76              ADDS     r6,r6,#1
;;;671    
;;;672            tCAN->IF[u32MsgIfNum].CREQ = 1ul + u8MsgObj;
000072  6206              STR      r6,[r0,#0x20]
;;;673            ReleaseIF(tCAN, u32MsgIfNum);
000074  4640              MOV      r0,r8
000076  f7fffffe          BL       ReleaseIF
                  |L20.122|
;;;674        }
;;;675    
;;;676        return rev;
00007a  4628              MOV      r0,r5
;;;677    }
00007c  e8bd87f0          POP      {r4-r10,pc}
;;;678    
                          ENDP


                          AREA ||i.CAN_SetRxMsgObjAndMsk||, CODE, READONLY, ALIGN=1

                  CAN_SetRxMsgObjAndMsk PROC
;;;558      */
;;;559    int32_t CAN_SetRxMsgObjAndMsk(CAN_T *tCAN, uint8_t u8MsgObj, uint8_t u8idType, uint32_t u32id, uint32_t u32idmask, uint8_t u8singleOrFifoLast)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;560    {
000004  461c              MOV      r4,r3
000006  e9dd6a08          LDRD     r6,r10,[sp,#0x20]
00000a  4690              MOV      r8,r2
00000c  460f              MOV      r7,r1
00000e  4681              MOV      r9,r0
;;;561        int32_t rev = 1l;
000010  2501              MOVS     r5,#1
;;;562        uint32_t u32MsgIfNum;
;;;563    
;;;564        /* Get and lock a free interface */
;;;565        if((u32MsgIfNum = LockIF_TL(tCAN)) == 2ul)
000012  f7fffffe          BL       LockIF_TL
000016  4601              MOV      r1,r0
000018  2802              CMP      r0,#2
00001a  d01e              BEQ      |L21.90|
;;;566        {
;;;567            rev = 0; /* return FALSE */
;;;568        }
;;;569        else
;;;570        {
;;;571            /* Command Setting */
;;;572            tCAN->IF[u32MsgIfNum].CMASK = CAN_IF_CMASK_WRRD_Msk | CAN_IF_CMASK_MASK_Msk | CAN_IF_CMASK_ARB_Msk |
00001c  eb010341          ADD      r3,r1,r1,LSL #1
000020  eb091043          ADD      r0,r9,r3,LSL #5
000024  22f3              MOVS     r2,#0xf3
000026  6242              STR      r2,[r0,#0x24]
000028  2200              MOVS     r2,#0
;;;573                                          CAN_IF_CMASK_CONTROL_Msk | CAN_IF_CMASK_DATAA_Msk | CAN_IF_CMASK_DATAB_Msk;
;;;574    
;;;575            if(u8idType == CAN_STD_ID)    /* According STD/EXT ID format,Configure Mask and Arbitration register */
00002a  f1b80f00          CMP      r8,#0
00002e  d016              BEQ      |L21.94|
;;;576            {
;;;577                tCAN->IF[u32MsgIfNum].ARB1 = 0ul;
;;;578                tCAN->IF[u32MsgIfNum].ARB2 = CAN_IF_ARB2_MSGVAL_Msk | (u32id & 0x7FFul) << 2;
;;;579            }
;;;580            else
;;;581            {
;;;582                tCAN->IF[u32MsgIfNum].ARB1 = u32id & 0xFFFFul;
000030  b2a3              UXTH     r3,r4
000032  6303              STR      r3,[r0,#0x30]
;;;583                tCAN->IF[u32MsgIfNum].ARB2 = CAN_IF_ARB2_MSGVAL_Msk | CAN_IF_ARB2_XTD_Msk | (u32id & 0x1FFF0000ul) >> 16;
000034  f3c4430c          UBFX     r3,r4,#16,#13
000038  f4434340          ORR      r3,r3,#0xc000
                  |L21.60|
00003c  6343              STR      r3,[r0,#0x34]
;;;584            }
;;;585    
;;;586            tCAN->IF[u32MsgIfNum].MASK1 = (u32idmask & 0xFFFFul);
00003e  b2b3              UXTH     r3,r6
000040  6283              STR      r3,[r0,#0x28]
;;;587            tCAN->IF[u32MsgIfNum].MASK2 = (u32idmask >> 16) & 0xFFFFul;
000042  0c33              LSRS     r3,r6,#16
000044  62c3              STR      r3,[r0,#0x2c]
;;;588    
;;;589            /* tCAN->IF[u32MsgIfNum].MCON |= CAN_IF_MCON_UMASK_Msk | CAN_IF_MCON_RXIE_Msk; */
;;;590            tCAN->IF[u32MsgIfNum].MCON = CAN_IF_MCON_UMASK_Msk | CAN_IF_MCON_RXIE_Msk;
000046  f44f53a0          MOV      r3,#0x1400
00004a  6383              STR      r3,[r0,#0x38]
;;;591            if(u8singleOrFifoLast)
;;;592            {
;;;593                tCAN->IF[u32MsgIfNum].MCON |= CAN_IF_MCON_EOB_Msk;
;;;594            }
;;;595            else
;;;596            {
;;;597                tCAN->IF[u32MsgIfNum].MCON &= (~CAN_IF_MCON_EOB_Msk);
00004c  6b83              LDR      r3,[r0,#0x38]
00004e  f1ba0f00          CMP      r10,#0                ;591
000052  d00c              BEQ      |L21.110|
000054  f0430380          ORR      r3,r3,#0x80           ;593
000058  e00b              B        |L21.114|
                  |L21.90|
00005a  2500              MOVS     r5,#0                 ;567
00005c  e013              B        |L21.134|
                  |L21.94|
00005e  6302              STR      r2,[r0,#0x30]         ;577
000060  f3c4030a          UBFX     r3,r4,#0,#11          ;578
000064  f44f4400          MOV      r4,#0x8000            ;578
000068  ea440383          ORR      r3,r4,r3,LSL #2       ;578
00006c  e7e6              B        |L21.60|
                  |L21.110|
00006e  f0230380          BIC      r3,r3,#0x80
                  |L21.114|
000072  6383              STR      r3,[r0,#0x38]
;;;598            }
;;;599    
;;;600            tCAN->IF[u32MsgIfNum].DAT_A1  = 0ul;
000074  63c2              STR      r2,[r0,#0x3c]
;;;601            tCAN->IF[u32MsgIfNum].DAT_A2  = 0ul;
000076  6402              STR      r2,[r0,#0x40]
;;;602            tCAN->IF[u32MsgIfNum].DAT_B1  = 0ul;
000078  6442              STR      r2,[r0,#0x44]
;;;603            tCAN->IF[u32MsgIfNum].DAT_B2  = 0ul;
00007a  6482              STR      r2,[r0,#0x48]
00007c  1c7f              ADDS     r7,r7,#1
;;;604    
;;;605            tCAN->IF[u32MsgIfNum].CREQ = 1ul + u8MsgObj;
00007e  6207              STR      r7,[r0,#0x20]
;;;606            ReleaseIF(tCAN, u32MsgIfNum);
000080  4648              MOV      r0,r9
000082  f7fffffe          BL       ReleaseIF
                  |L21.134|
;;;607        }
;;;608    
;;;609        return rev;
000086  4628              MOV      r0,r5
;;;610    }
000088  e8bd87f0          POP      {r4-r10,pc}
;;;611    
                          ENDP


                          AREA ||i.CAN_SetRxMsgObj_Remote||, CODE, READONLY, ALIGN=1

                  CAN_SetRxMsgObj_Remote PROC
;;;1321   
;;;1322   int32_t CAN_SetRxMsgObj_Remote(CAN_T *tCAN, uint8_t u8MsgObj, uint8_t u8idType, uint32_t u32id, uint8_t u8singleOrFifoLast)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1323   {
000004  461c              MOV      r4,r3
000006  4617              MOV      r7,r2
000008  460e              MOV      r6,r1
00000a  4680              MOV      r8,r0
;;;1324       int32_t rev = 1l;
00000c  2501              MOVS     r5,#1
;;;1325       uint32_t u32MsgIfNum;
;;;1326   
;;;1327       /* Get and lock a free interface */
;;;1328       if((u32MsgIfNum = LockIF_TL(tCAN)) == 2ul)
00000e  f8dd9020          LDR      r9,[sp,#0x20]
000012  f7fffffe          BL       LockIF_TL
000016  4601              MOV      r1,r0
000018  2802              CMP      r0,#2
00001a  d01c              BEQ      |L22.86|
;;;1329       {
;;;1330           rev = 0; /* return FALSE */
;;;1331       }
;;;1332       else
;;;1333       {
;;;1334           /* Command Setting */
;;;1335           tCAN->IF[u32MsgIfNum].CMASK = CAN_IF_CMASK_WRRD_Msk | CAN_IF_CMASK_MASK_Msk | CAN_IF_CMASK_ARB_Msk |
00001c  eb010341          ADD      r3,r1,r1,LSL #1
000020  eb081043          ADD      r0,r8,r3,LSL #5
000024  22f3              MOVS     r2,#0xf3
000026  6242              STR      r2,[r0,#0x24]
000028  2200              MOVS     r2,#0
;;;1336                                         CAN_IF_CMASK_CONTROL_Msk | CAN_IF_CMASK_DATAA_Msk | CAN_IF_CMASK_DATAB_Msk;
;;;1337   
;;;1338           if(u8idType == CAN_STD_ID)    /* According STD/EXT ID format,Configure Mask and Arbitration register */
00002a  b1b7              CBZ      r7,|L22.90|
;;;1339           {
;;;1340               tCAN->IF[u32MsgIfNum].ARB1 = 0ul;
;;;1341               tCAN->IF[u32MsgIfNum].ARB2 = CAN_IF_ARB2_MSGVAL_Msk | (u32id & 0x7FFul) << 2;
;;;1342           }
;;;1343           else
;;;1344           {
;;;1345               tCAN->IF[u32MsgIfNum].ARB1 = u32id & 0xFFFFul;
00002c  b2a3              UXTH     r3,r4
00002e  6303              STR      r3,[r0,#0x30]
;;;1346               tCAN->IF[u32MsgIfNum].ARB2 = CAN_IF_ARB2_MSGVAL_Msk | CAN_IF_ARB2_XTD_Msk | (u32id & 0x1FFF0000ul) >> 16;
000030  f3c4430c          UBFX     r3,r4,#16,#13
000034  f4434340          ORR      r3,r3,#0xc000
                  |L22.56|
000038  6343              STR      r3,[r0,#0x34]
;;;1347           }
;;;1348   
;;;1349   		 tCAN->IF[u32MsgIfNum].ARB2 |= CAN_IF_ARB2_DIR_Msk;
00003a  6b43              LDR      r3,[r0,#0x34]
00003c  f4435300          ORR      r3,r3,#0x2000
000040  6343              STR      r3,[r0,#0x34]
;;;1350   		
;;;1351           //tCAN->IF[u8MsgIfNum].MCON |= CAN_IF_MCON_UMASK_Msk | CAN_IF_MCON_RXIE_Msk; 
;;;1352           //tCAN->IF[u32MsgIfNum].MCON = CAN_IF_MCON_UMASK_Msk | CAN_IF_MCON_RXIE_Msk | CAN_IF_MCON_RmtEn_Msk;
;;;1353   		tCAN->IF[u32MsgIfNum].MCON = CAN_IF_MCON_UMASK_Msk | CAN_IF_MCON_RXIE_Msk;
000042  f44f53a0          MOV      r3,#0x1400
000046  6383              STR      r3,[r0,#0x38]
;;;1354           if(u8singleOrFifoLast)
;;;1355           {
;;;1356               tCAN->IF[u32MsgIfNum].MCON |= CAN_IF_MCON_EOB_Msk;
;;;1357           }
;;;1358           else
;;;1359           {
;;;1360               tCAN->IF[u32MsgIfNum].MCON &= (~CAN_IF_MCON_EOB_Msk);
000048  6b83              LDR      r3,[r0,#0x38]
00004a  f1b90f00          CMP      r9,#0                 ;1354
00004e  d00c              BEQ      |L22.106|
000050  f0430380          ORR      r3,r3,#0x80           ;1356
000054  e00b              B        |L22.110|
                  |L22.86|
000056  2500              MOVS     r5,#0                 ;1330
000058  e013              B        |L22.130|
                  |L22.90|
00005a  6302              STR      r2,[r0,#0x30]         ;1340
00005c  f3c4030a          UBFX     r3,r4,#0,#11          ;1341
000060  f44f4400          MOV      r4,#0x8000            ;1341
000064  ea440383          ORR      r3,r4,r3,LSL #2       ;1341
000068  e7e6              B        |L22.56|
                  |L22.106|
00006a  f0230380          BIC      r3,r3,#0x80
                  |L22.110|
00006e  6383              STR      r3,[r0,#0x38]
;;;1361           }
;;;1362   
;;;1363           tCAN->IF[u32MsgIfNum].DAT_A1  = 0ul;
000070  63c2              STR      r2,[r0,#0x3c]
;;;1364           tCAN->IF[u32MsgIfNum].DAT_A2  = 0ul;
000072  6402              STR      r2,[r0,#0x40]
;;;1365           tCAN->IF[u32MsgIfNum].DAT_B1  = 0ul;
000074  6442              STR      r2,[r0,#0x44]
;;;1366           tCAN->IF[u32MsgIfNum].DAT_B2  = 0ul;
000076  6482              STR      r2,[r0,#0x48]
000078  1c76              ADDS     r6,r6,#1
;;;1367   
;;;1368           tCAN->IF[u32MsgIfNum].CREQ = 1ul + u8MsgObj;
00007a  6206              STR      r6,[r0,#0x20]
;;;1369           ReleaseIF(tCAN, u32MsgIfNum);
00007c  4640              MOV      r0,r8
00007e  f7fffffe          BL       ReleaseIF
                  |L22.130|
;;;1370       }
;;;1371   
;;;1372       return rev;
000082  4628              MOV      r0,r5
;;;1373   }
000084  e8bd87f0          POP      {r4-r10,pc}
;;;1374   
                          ENDP


                          AREA ||i.CAN_SetRxMsg_Remote||, CODE, READONLY, ALIGN=1

                  CAN_SetRxMsg_Remote PROC
;;;1375   
;;;1376   int32_t CAN_SetRxMsg_Remote(CAN_T *tCAN, uint32_t u32MsgNum, uint32_t u32IDType, uint32_t u32ID)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1377   {
;;;1378       int32_t rev = (int32_t)TRUE;
000004  2501              MOVS     r5,#1
000006  469a              MOV      r10,r3                ;1377
000008  4616              MOV      r6,r2                 ;1377
00000a  460f              MOV      r7,r1                 ;1377
00000c  4683              MOV      r11,r0                ;1377
;;;1379       uint32_t u32TimeOutCount = 0ul;
00000e  2400              MOVS     r4,#0
;;;1380   
;;;1381       while(CAN_SetRxMsgObj_Remote(tCAN, (uint8_t)u32MsgNum, (uint8_t)u32IDType, u32ID, (uint8_t)TRUE) == (int32_t)FALSE)
;;;1382       {
;;;1383           if(++u32TimeOutCount >= RETRY_COUNTS)
000010  f04f5980          MOV      r9,#0x10000000
000014  46a8              MOV      r8,r5                 ;1378
000016  e004              B        |L23.34|
                  |L23.24|
000018  1c64              ADDS     r4,r4,#1              ;1377
00001a  454c              CMP      r4,r9
00001c  d301              BCC      |L23.34|
;;;1384           {
;;;1385               rev = (int32_t)(FALSE); /* return FALSE */
00001e  2500              MOVS     r5,#0
;;;1386               break;
000020  e009              B        |L23.54|
                  |L23.34|
000022  b2f2              UXTB     r2,r6                 ;1381
000024  b2f9              UXTB     r1,r7                 ;1381
000026  4653              MOV      r3,r10                ;1381
000028  4658              MOV      r0,r11                ;1381
00002a  f8cd8000          STR      r8,[sp,#0]            ;1381
00002e  f7fffffe          BL       CAN_SetRxMsgObj_Remote
000032  2800              CMP      r0,#0                 ;1381
000034  d0f0              BEQ      |L23.24|
                  |L23.54|
;;;1387           }
;;;1388           else
;;;1389           {
;;;1390           }
;;;1391       }
;;;1392   
;;;1393       return rev;
000036  4628              MOV      r0,r5
;;;1394   }
000038  e8bd8ff8          POP      {r3-r11,pc}
;;;1395   
                          ENDP


                          AREA ||i.CAN_SetTxMsg||, CODE, READONLY, ALIGN=1

                  CAN_SetTxMsg PROC
;;;955      */
;;;956    int32_t CAN_SetTxMsg(CAN_T *tCAN, uint32_t u32MsgNum, STR_CANMSG_T* pCanMsg)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;957    {
000004  4614              MOV      r4,r2
000006  460e              MOV      r6,r1
000008  4607              MOV      r7,r0
;;;958        int32_t rev = 1l;
00000a  2501              MOVS     r5,#1
;;;959        uint32_t u32MsgIfNum;
;;;960    
;;;961        if((u32MsgIfNum = LockIF_TL(tCAN)) == 2ul)
00000c  f7fffffe          BL       LockIF_TL
000010  4601              MOV      r1,r0
000012  2802              CMP      r0,#2
000014  d017              BEQ      |L24.70|
;;;962        {
;;;963            rev = 0; /* return FALSE */
;;;964        }
;;;965        else
;;;966        {
;;;967            /* update the contents needed for transmission*/
;;;968            tCAN->IF[u32MsgIfNum].CMASK = CAN_IF_CMASK_WRRD_Msk | CAN_IF_CMASK_MASK_Msk | CAN_IF_CMASK_ARB_Msk |
000016  eb010041          ADD      r0,r1,r1,LSL #1
00001a  eb071040          ADD      r0,r7,r0,LSL #5
00001e  22f3              MOVS     r2,#0xf3
000020  6242              STR      r2,[r0,#0x24]
;;;969                                          CAN_IF_CMASK_CONTROL_Msk | CAN_IF_CMASK_DATAA_Msk  | CAN_IF_CMASK_DATAB_Msk;
;;;970    
;;;971            if(pCanMsg->IdType == CAN_STD_ID)
000022  6822              LDR      r2,[r4,#0]
000024  b18a              CBZ      r2,|L24.74|
;;;972            {
;;;973                /* standard ID*/
;;;974                tCAN->IF[u32MsgIfNum].ARB1 = 0ul;
;;;975                tCAN->IF[u32MsgIfNum].ARB2 = (((pCanMsg->Id) & 0x7FFul) << 2) | CAN_IF_ARB2_DIR_Msk | CAN_IF_ARB2_MSGVAL_Msk;
;;;976            }
;;;977            else
;;;978            {
;;;979                /* extended ID*/
;;;980                tCAN->IF[u32MsgIfNum].ARB1 = (pCanMsg->Id) & 0xFFFFul;
000026  8922              LDRH     r2,[r4,#8]
000028  b292              UXTH     r2,r2
00002a  6302              STR      r2,[r0,#0x30]
;;;981                tCAN->IF[u32MsgIfNum].ARB2 = ((pCanMsg->Id) & 0x1FFF0000ul) >> 16 |
00002c  68a2              LDR      r2,[r4,#8]
00002e  f3c2420c          UBFX     r2,r2,#16,#13
000032  f4424260          ORR      r2,r2,#0xe000
                  |L24.54|
000036  6342              STR      r2,[r0,#0x34]
;;;982                                             CAN_IF_ARB2_DIR_Msk | CAN_IF_ARB2_XTD_Msk | CAN_IF_ARB2_MSGVAL_Msk;
;;;983            }
;;;984    
;;;985            if(pCanMsg->FrameType)
000038  6862              LDR      r2,[r4,#4]
00003a  2a00              CMP      r2,#0
;;;986            {
;;;987                tCAN->IF[u32MsgIfNum].ARB2 |=   CAN_IF_ARB2_DIR_Msk;
;;;988            }
;;;989            else
;;;990            {
;;;991                tCAN->IF[u32MsgIfNum].ARB2 &= (~CAN_IF_ARB2_DIR_Msk);
00003c  6b42              LDR      r2,[r0,#0x34]
00003e  d00e              BEQ      |L24.94|
000040  f4425200          ORR      r2,r2,#0x2000         ;987
000044  e00d              B        |L24.98|
                  |L24.70|
000046  2500              MOVS     r5,#0                 ;963
000048  e020              B        |L24.140|
                  |L24.74|
00004a  2200              MOVS     r2,#0                 ;974
00004c  6302              STR      r2,[r0,#0x30]         ;974
00004e  8922              LDRH     r2,[r4,#8]            ;975
000050  f44f4320          MOV      r3,#0xa000            ;975
000054  f3c2020a          UBFX     r2,r2,#0,#11          ;975
000058  ea430282          ORR      r2,r3,r2,LSL #2       ;975
00005c  e7eb              B        |L24.54|
                  |L24.94|
00005e  f4225200          BIC      r2,r2,#0x2000
                  |L24.98|
000062  6342              STR      r2,[r0,#0x34]
;;;992            }
;;;993    
;;;994            tCAN->IF[u32MsgIfNum].DAT_A1 = (uint16_t)((uint16_t)(((uint16_t)pCanMsg->Data[1] << 8)) | pCanMsg->Data[0]);
000064  f8342f0d          LDRH     r2,[r4,#0xd]!
000068  63c2              STR      r2,[r0,#0x3c]
;;;995            tCAN->IF[u32MsgIfNum].DAT_A2 = (uint16_t)((uint16_t)(((uint16_t)pCanMsg->Data[3] << 8)) | pCanMsg->Data[2]);
00006a  8862              LDRH     r2,[r4,#2]
00006c  6402              STR      r2,[r0,#0x40]
;;;996            tCAN->IF[u32MsgIfNum].DAT_B1 = (uint16_t)((uint16_t)(((uint16_t)pCanMsg->Data[5] << 8)) | pCanMsg->Data[4]);
00006e  88a2              LDRH     r2,[r4,#4]
000070  6442              STR      r2,[r0,#0x44]
;;;997            tCAN->IF[u32MsgIfNum].DAT_B2 = (uint16_t)((uint16_t)(((uint16_t)pCanMsg->Data[7] << 8)) | pCanMsg->Data[6]);
000072  88e2              LDRH     r2,[r4,#6]
000074  6482              STR      r2,[r0,#0x48]
;;;998    
;;;999            tCAN->IF[u32MsgIfNum].MCON   =  CAN_IF_MCON_NEWDAT_Msk | pCanMsg->DLC | CAN_IF_MCON_TXIE_Msk | CAN_IF_MCON_EOB_Msk;
000076  f8142c01          LDRB     r2,[r4,#-1]
00007a  f6480380          MOV      r3,#0x8880
00007e  431a              ORRS     r2,r2,r3
000080  6382              STR      r2,[r0,#0x38]
000082  1c76              ADDS     r6,r6,#1
;;;1000           tCAN->IF[u32MsgIfNum].CREQ   = 1ul + u32MsgNum;
000084  6206              STR      r6,[r0,#0x20]
;;;1001   
;;;1002           ReleaseIF(tCAN, u32MsgIfNum);
000086  4638              MOV      r0,r7
000088  f7fffffe          BL       ReleaseIF
                  |L24.140|
;;;1003       }
;;;1004   
;;;1005       return rev;
00008c  4628              MOV      r0,r5
;;;1006   }
00008e  e8bd81f0          POP      {r4-r8,pc}
;;;1007   
                          ENDP


                          AREA ||i.CAN_Transmit||, CODE, READONLY, ALIGN=1

                  CAN_Transmit PROC
;;;1234     */
;;;1235   int32_t CAN_Transmit(CAN_T *tCAN, uint32_t u32MsgNum, STR_CANMSG_T* pCanMsg)
000000  b570              PUSH     {r4-r6,lr}
;;;1236   {
000002  4605              MOV      r5,r0
;;;1237       int32_t rev = (int32_t)TRUE;
;;;1238       uint32_t u32Tmp;
;;;1239   
;;;1240       u32Tmp = (tCAN->TEST & CAN_TEST_BASIC_Msk);
000004  6940              LDR      r0,[r0,#0x14]
000006  460e              MOV      r6,r1                 ;1236
000008  2401              MOVS     r4,#1                 ;1237
;;;1241   
;;;1242       if((tCAN->CON & CAN_CON_TEST_Msk) && u32Tmp)
00000a  6829              LDR      r1,[r5,#0]
00000c  f0000004          AND      r0,r0,#4              ;1240
000010  0609              LSLS     r1,r1,#24
000012  d507              BPL      |L25.36|
000014  b130              CBZ      r0,|L25.36|
;;;1243       {
;;;1244           rev = CAN_BasicSendMsg(tCAN, pCanMsg);
000016  4611              MOV      r1,r2
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       CAN_BasicSendMsg
00001e  0004              MOVS     r4,r0
;;;1245           if(rev < 0) rev = 0;
000020  d40b              BMI      |L25.58|
000022  e008              B        |L25.54|
                  |L25.36|
;;;1246       }
;;;1247       else
;;;1248       {
;;;1249           if(CAN_SetTxMsg(tCAN, u32MsgNum, pCanMsg) == FALSE)
000024  4631              MOV      r1,r6
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       CAN_SetTxMsg
00002c  b128              CBZ      r0,|L25.58|
;;;1250           {
;;;1251               rev = (int32_t)FALSE;
;;;1252           }
;;;1253           else
;;;1254           {
;;;1255               CAN_TriggerTxMsg(tCAN, u32MsgNum);
00002e  4631              MOV      r1,r6
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       CAN_TriggerTxMsg
                  |L25.54|
;;;1256           }
;;;1257       }
;;;1258   
;;;1259       return rev;
000036  4620              MOV      r0,r4
;;;1260   }
000038  bd70              POP      {r4-r6,pc}
                  |L25.58|
00003a  2400              MOVS     r4,#0                 ;1251
00003c  e7fb              B        |L25.54|
;;;1261   
                          ENDP


                          AREA ||i.CAN_TriggerTxMsg||, CODE, READONLY, ALIGN=2

                  CAN_TriggerTxMsg PROC
;;;1019     */
;;;1020   int32_t CAN_TriggerTxMsg(CAN_T  *tCAN, uint32_t u32MsgNum)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1021   {
000004  4605              MOV      r5,r0
;;;1022       int32_t rev = 1l;
;;;1023       uint32_t u32MsgIfNum;
;;;1024       uint32_t u32TimeOutCount = SystemCoreClock; // 1 second timeout
000006  4816              LDR      r0,|L26.96|
000008  460f              MOV      r7,r1                 ;1021
00000a  2601              MOVS     r6,#1                 ;1022
;;;1025   
;;;1026       if((u32MsgIfNum = LockIF_TL(tCAN)) == 2ul)
00000c  6804              LDR      r4,[r0,#0]  ; SystemCoreClock
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       LockIF_TL
000014  4601              MOV      r1,r0
000016  2802              CMP      r0,#2
000018  d00c              BEQ      |L26.52|
;;;1027       {
;;;1028           rev = 0; /* return FALSE */
;;;1029       }
;;;1030       else
;;;1031       {
;;;1032           tCAN->STATUS &= (~CAN_STATUS_TXOK_Msk);
00001a  6868              LDR      r0,[r5,#4]
00001c  f0200008          BIC      r0,r0,#8
000020  6068              STR      r0,[r5,#4]
;;;1033   
;;;1034           /* read the message contents*/
;;;1035           tCAN->IF[u32MsgIfNum].CMASK = CAN_IF_CMASK_CLRINTPND_Msk
000022  eb010041          ADD      r0,r1,r1,LSL #1
000026  eb051040          ADD      r0,r5,r0,LSL #5
00002a  220c              MOVS     r2,#0xc
00002c  6242              STR      r2,[r0,#0x24]
00002e  1c7f              ADDS     r7,r7,#1
;;;1036                                         | CAN_IF_CMASK_TXRQSTNEWDAT_Msk;
;;;1037   
;;;1038           tCAN->IF[u32MsgIfNum].CREQ = 1ul + u32MsgNum;
000030  6207              STR      r7,[r0,#0x20]
;;;1039   
;;;1040           while(tCAN->IF[u32MsgIfNum].CREQ & CAN_IF_CREQ_BUSY_Msk) /*Wait*/
000032  e003              B        |L26.60|
                  |L26.52|
000034  2600              MOVS     r6,#0                 ;1028
000036  e00a              B        |L26.78|
                  |L26.56|
;;;1041           {
;;;1042               if(u32TimeOutCount == 0)
000038  b164              CBZ      r4,|L26.84|
00003a  1e64              SUBS     r4,r4,#1
                  |L26.60|
00003c  6a02              LDR      r2,[r0,#0x20]         ;1040
00003e  0412              LSLS     r2,r2,#16             ;1040
000040  d4fa              BMI      |L26.56|
;;;1043               {
;;;1044                   ReleaseIF(tCAN, u32MsgIfNum);
;;;1045                   return -1;
;;;1046               }
;;;1047               u32TimeOutCount--;
;;;1048           }
;;;1049           tCAN->IF[u32MsgIfNum].CMASK  = CAN_IF_CMASK_WRRD_Msk | CAN_IF_CMASK_TXRQSTNEWDAT_Msk;
000042  2284              MOVS     r2,#0x84
000044  6242              STR      r2,[r0,#0x24]
;;;1050           tCAN->IF[u32MsgIfNum].CREQ  = 1ul + u32MsgNum;
000046  6207              STR      r7,[r0,#0x20]
;;;1051   
;;;1052           ReleaseIF(tCAN, u32MsgIfNum);
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       ReleaseIF
                  |L26.78|
;;;1053       }
;;;1054   
;;;1055       return rev;
00004e  4630              MOV      r0,r6
                  |L26.80|
;;;1056   }
000050  e8bd81f0          POP      {r4-r8,pc}
                  |L26.84|
000054  4628              MOV      r0,r5                 ;1044
000056  f7fffffe          BL       ReleaseIF
00005a  f04f30ff          MOV      r0,#0xffffffff        ;1045
00005e  e7f7              B        |L26.80|
;;;1057   
                          ENDP

                  |L26.96|
                          DCD      SystemCoreClock

                          AREA ||i.CAN_WaitMsg||, CODE, READONLY, ALIGN=1

                  CAN_WaitMsg PROC
;;;278      */
;;;279    void CAN_WaitMsg(CAN_T *tCAN)
000000  2100              MOVS     r1,#0
;;;280    {
;;;281        tCAN->STATUS = 0x0ul; /* clr status */
000002  6041              STR      r1,[r0,#4]
                  |L27.4|
;;;282    
;;;283        while(1)
;;;284        {
;;;285            if(tCAN->IF[1].MCON & CAN_IF_MCON_NEWDAT_Msk)   /* check new data */
000004  f8d01098          LDR      r1,[r0,#0x98]
000008  0409              LSLS     r1,r1,#16
00000a  d402              BMI      |L27.18|
;;;286            {
;;;287                /* New Data IN */
;;;288                break;
;;;289            }
;;;290            else
;;;291            {
;;;292            }
;;;293    
;;;294            if(tCAN->STATUS & CAN_STATUS_RXOK_Msk)
00000c  6841              LDR      r1,[r0,#4]
;;;295            {
;;;296                /* Rx OK */
;;;297            }
;;;298            else
;;;299            {
;;;300            }
;;;301    
;;;302            if(tCAN->STATUS & CAN_STATUS_LEC_Msk)
00000e  6841              LDR      r1,[r0,#4]
000010  e7f8              B        |L27.4|
                  |L27.18|
;;;303            {
;;;304                /* Error */
;;;305            }
;;;306            else
;;;307            {
;;;308            }
;;;309        }
;;;310    }
000012  4770              BX       lr
;;;311    
                          ENDP


                          AREA ||i.LockIF||, CODE, READONLY, ALIGN=2

                  LockIF PROC
;;;60       */
;;;61     static uint32_t LockIF(CAN_T *tCAN)
000000  b570              PUSH     {r4-r6,lr}
;;;62     {
;;;63         uint32_t u32CanNo;
;;;64         uint32_t u32FreeIfNo;
;;;65         uint32_t u32IntMask;
;;;66     
;;;67     #if defined(CAN1)
;;;68         if(tCAN == CAN0)
000002  4a19              LDR      r2,|L28.104|
000004  4290              CMP      r0,r2
000006  d101              BNE      |L28.12|
;;;69             u32CanNo = 0ul;
000008  2100              MOVS     r1,#0
00000a  e008              B        |L28.30|
                  |L28.12|
;;;70         else if(tCAN == CAN1)
00000c  4a17              LDR      r2,|L28.108|
00000e  4290              CMP      r0,r2
000010  d101              BNE      |L28.22|
;;;71             u32CanNo = 1ul;
000012  2101              MOVS     r1,#1
000014  e003              B        |L28.30|
                  |L28.22|
;;;72         #if defined(CAN2)
;;;73         else if(tCAN == CAN2)
000016  4a16              LDR      r2,|L28.112|
000018  4290              CMP      r0,r2
00001a  d100              BNE      |L28.30|
;;;74             u32CanNo = 2ul;
00001c  2102              MOVS     r1,#2
                  |L28.30|
;;;75         #endif
;;;76     #else /* defined(CAN0) || defined(CAN) */
;;;77         u32CanNo = 0ul;
;;;78     #endif
;;;79     
;;;80         u32FreeIfNo = 2ul;
;;;81     
;;;82         /* Disable CAN interrupt */
;;;83         u32IntMask = tCAN->CON & (CAN_CON_IE_Msk | CAN_CON_SIE_Msk | CAN_CON_EIE_Msk);
00001e  6803              LDR      r3,[r0,#0]
000020  2202              MOVS     r2,#2                 ;80
;;;84         tCAN->CON = tCAN->CON & ~(CAN_CON_IE_Msk | CAN_CON_SIE_Msk | CAN_CON_EIE_Msk);
000022  6804              LDR      r4,[r0,#0]
000024  f003030e          AND      r3,r3,#0xe            ;83
000028  f024040e          BIC      r4,r4,#0xe
00002c  6004              STR      r4,[r0,#0]
;;;85     
;;;86         /* Check interface 1 is available or not */
;;;87         if((tCAN->IF[0ul].CREQ & CAN_IF_CREQ_BUSY_Msk) == 0ul)
00002e  6a04              LDR      r4,[r0,#0x20]
000030  f04f0501          MOV      r5,#1                 ;71
000034  0426              LSLS     r6,r4,#16
;;;88         {
;;;89             if(gu8LockCanIf[u32CanNo][0ul] == 0ul)
000036  4c0f              LDR      r4,|L28.116|
000038  d402              BMI      |L28.64|
00003a  f8146011          LDRB     r6,[r4,r1,LSL #1]
00003e  b146              CBZ      r6,|L28.82|
                  |L28.64|
;;;90             {
;;;91                 gu8LockCanIf[u32CanNo][0ul] = 1u;
;;;92                 u32FreeIfNo = 0ul;
;;;93             }
;;;94             else
;;;95             {
;;;96             }
;;;97         }
;;;98         else
;;;99         {
;;;100        }
;;;101    
;;;102        /* Or check interface 2 is available or not */
;;;103        if(u32FreeIfNo == 2ul)
;;;104        {
;;;105            if((tCAN->IF[1ul].CREQ & CAN_IF_CREQ_BUSY_Msk) == 0ul)
000040  f8d06080          LDR      r6,[r0,#0x80]
000044  0436              LSLS     r6,r6,#16
000046  d40a              BMI      |L28.94|
;;;106            {
;;;107                if(gu8LockCanIf[u32CanNo][1ul] == 0ul)
000048  eb040141          ADD      r1,r4,r1,LSL #1
00004c  784c              LDRB     r4,[r1,#1]
00004e  b124              CBZ      r4,|L28.90|
000050  e005              B        |L28.94|
                  |L28.82|
000052  f8045011          STRB     r5,[r4,r1,LSL #1]     ;91
000056  2200              MOVS     r2,#0                 ;92
000058  e001              B        |L28.94|
                  |L28.90|
;;;108                {
;;;109                    gu8LockCanIf[u32CanNo][1ul] = 1u;
00005a  704d              STRB     r5,[r1,#1]
;;;110                    u32FreeIfNo = 1ul;
00005c  2201              MOVS     r2,#1
                  |L28.94|
;;;111                }
;;;112                else
;;;113                {
;;;114                }
;;;115            }
;;;116            else
;;;117            {
;;;118            }
;;;119        }
;;;120        else
;;;121        {
;;;122        }
;;;123    
;;;124        /* Enable CAN interrupt */
;;;125        tCAN->CON |= u32IntMask;
00005e  6801              LDR      r1,[r0,#0]
000060  4319              ORRS     r1,r1,r3
000062  6001              STR      r1,[r0,#0]
;;;126    
;;;127        return u32FreeIfNo;
000064  4610              MOV      r0,r2
;;;128    }
000066  bd70              POP      {r4-r6,pc}
;;;129    
                          ENDP

                  |L28.104|
                          DCD      0x400a0000
                  |L28.108|
                          DCD      0x400a1000
                  |L28.112|
                          DCD      0x400a2000
                  |L28.116|
                          DCD      ||.data||

                          AREA ||i.LockIF_TL||, CODE, READONLY, ALIGN=1

                  LockIF_TL PROC
;;;139      */
;;;140    static uint32_t LockIF_TL(CAN_T *tCAN)
000000  b570              PUSH     {r4-r6,lr}
;;;141    {
000002  4606              MOV      r6,r0
;;;142        uint32_t u32Count;
;;;143        uint32_t u32FreeIfNo;
;;;144    
;;;145        for(u32Count = 0ul; u32Count < RETRY_COUNTS; u32Count++)
000004  2400              MOVS     r4,#0
000006  f04f5580          MOV      r5,#0x10000000
                  |L29.10|
;;;146        {
;;;147            if((u32FreeIfNo = LockIF(tCAN)) != 2ul)
00000a  4630              MOV      r0,r6
00000c  f7fffffe          BL       LockIF
000010  2802              CMP      r0,#2
000012  d102              BNE      |L29.26|
000014  1c64              ADDS     r4,r4,#1
000016  42ac              CMP      r4,r5                 ;145
000018  d3f7              BCC      |L29.10|
                  |L29.26|
;;;148            {
;;;149                break;
;;;150            }
;;;151            else
;;;152            {
;;;153            }
;;;154        }
;;;155    
;;;156        return u32FreeIfNo;
;;;157    }
00001a  bd70              POP      {r4-r6,pc}
;;;158    
                          ENDP


                          AREA ||i.ReleaseIF||, CODE, READONLY, ALIGN=2

                  ReleaseIF PROC
;;;165      */
;;;166    static void ReleaseIF(CAN_T *tCAN, uint32_t u32IfNo)
000000  b530              PUSH     {r4,r5,lr}
;;;167    {
;;;168        uint32_t u32IntMask;
;;;169        uint32_t u32CanNo;
;;;170    
;;;171        if(u32IfNo >= 2ul)
000002  2902              CMP      r1,#2
000004  d21c              BCS      |L30.64|
;;;172        {
;;;173        }
;;;174        else
;;;175        {
;;;176    #if defined(CAN1)
;;;177        if(tCAN == CAN0)
000006  4b0f              LDR      r3,|L30.68|
000008  4298              CMP      r0,r3
00000a  d101              BNE      |L30.16|
;;;178            u32CanNo = 0ul;
00000c  2200              MOVS     r2,#0
00000e  e008              B        |L30.34|
                  |L30.16|
;;;179        else if(tCAN == CAN1)
000010  4b0d              LDR      r3,|L30.72|
000012  4298              CMP      r0,r3
000014  d101              BNE      |L30.26|
;;;180            u32CanNo = 1ul;
000016  2201              MOVS     r2,#1
000018  e003              B        |L30.34|
                  |L30.26|
;;;181        #if defined(CAN2)
;;;182        else if(tCAN == CAN2)
00001a  4b0c              LDR      r3,|L30.76|
00001c  4298              CMP      r0,r3
00001e  d100              BNE      |L30.34|
;;;183            u32CanNo = 2ul;
000020  2202              MOVS     r2,#2
                  |L30.34|
;;;184        #endif
;;;185    #else /* defined(CAN0) || defined(CAN) */
;;;186            u32CanNo = 0ul;
;;;187    #endif
;;;188    
;;;189            /* Disable CAN interrupt */
;;;190            u32IntMask = tCAN->CON & (CAN_CON_IE_Msk | CAN_CON_SIE_Msk | CAN_CON_EIE_Msk);
000022  6803              LDR      r3,[r0,#0]
;;;191            tCAN->CON = tCAN->CON & ~(CAN_CON_IE_Msk | CAN_CON_SIE_Msk | CAN_CON_EIE_Msk);
000024  6804              LDR      r4,[r0,#0]
000026  f003030e          AND      r3,r3,#0xe            ;190
00002a  f024040e          BIC      r4,r4,#0xe
00002e  6004              STR      r4,[r0,#0]
;;;192    
;;;193            gu8LockCanIf[u32CanNo][u32IfNo] = 0u;
000030  4d07              LDR      r5,|L30.80|
000032  2400              MOVS     r4,#0
000034  eb050242          ADD      r2,r5,r2,LSL #1
000038  5454              STRB     r4,[r2,r1]
;;;194    
;;;195            /* Enable CAN interrupt */
;;;196            tCAN->CON |= u32IntMask;
00003a  6801              LDR      r1,[r0,#0]
00003c  4319              ORRS     r1,r1,r3
00003e  6001              STR      r1,[r0,#0]
                  |L30.64|
;;;197        }
;;;198    }
000040  bd30              POP      {r4,r5,pc}
;;;199    
                          ENDP

000042  0000              DCW      0x0000
                  |L30.68|
                          DCD      0x400a0000
                  |L30.72|
                          DCD      0x400a1000
                  |L30.76|
                          DCD      0x400a2000
                  |L30.80|
                          DCD      ||.data||

                          AREA ||i.can_update_spt||, CODE, READONLY, ALIGN=1

                  can_update_spt PROC
;;;199    
;;;200    static int can_update_spt(int sampl_pt, int tseg, int *tseg1, int *tseg2)
000000  b530              PUSH     {r4,r5,lr}
;;;201    {
;;;202        *tseg2 = tseg + 1 - (sampl_pt * (tseg + 1)) / 1000;
000002  1c4c              ADDS     r4,r1,#1
000004  4360              MULS     r0,r4,r0
000006  f44f757a          MOV      r5,#0x3e8
00000a  fb90f0f5          SDIV     r0,r0,r5
00000e  1a08              SUBS     r0,r1,r0
000010  1c40              ADDS     r0,r0,#1
000012  6018              STR      r0,[r3,#0]            ;201
000014  d009              BEQ      |L31.42|
;;;203        if (*tseg2 < TSEG2_MIN)
;;;204        {
;;;205            *tseg2 = TSEG2_MIN;
;;;206        }
;;;207        else
;;;208        {
;;;209        }
;;;210    
;;;211        if (*tseg2 > TSEG2_MAX)
000016  2808              CMP      r0,#8
000018  d901              BLS      |L31.30|
;;;212        {
;;;213            *tseg2 = TSEG2_MAX;
00001a  2008              MOVS     r0,#8
                  |L31.28|
00001c  6018              STR      r0,[r3,#0]            ;205
                  |L31.30|
;;;214        }
;;;215        else
;;;216        {
;;;217        }
;;;218    
;;;219        *tseg1 = tseg - *tseg2;
00001e  1a08              SUBS     r0,r1,r0
;;;220        if (*tseg1 > TSEG1_MAX)
000020  6010              STR      r0,[r2,#0]
000022  2810              CMP      r0,#0x10
000024  d803              BHI      |L31.46|
;;;221        {
;;;222            *tseg1 = TSEG1_MAX;
;;;223            *tseg2 = tseg - *tseg1;
000026  6818              LDR      r0,[r3,#0]
000028  e006              B        |L31.56|
                  |L31.42|
00002a  2001              MOVS     r0,#1                 ;205
00002c  e7f6              B        |L31.28|
                  |L31.46|
00002e  2010              MOVS     r0,#0x10              ;222
000030  6010              STR      r0,[r2,#0]
000032  f1a10010          SUB      r0,r1,#0x10
000036  6018              STR      r0,[r3,#0]
                  |L31.56|
;;;224        }
;;;225        else
;;;226        {
;;;227        }
;;;228    
;;;229        return 1000 * (tseg + 1 - *tseg2) / (tseg + 1);
000038  1a08              SUBS     r0,r1,r0
00003a  f44f717a          MOV      r1,#0x3e8
00003e  1c40              ADDS     r0,r0,#1
000040  4348              MULS     r0,r1,r0
000042  fb90f0f4          SDIV     r0,r0,r4
;;;230    }
000046  bd30              POP      {r4,r5,pc}
;;;231    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  gu8LockCanIf
000000  00000000          DCB      0x00,0x00,0x00,0x00
000004  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\can.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_can_c_0fdded17____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_can_c_0fdded17____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_can_c_0fdded17____REVSH|
#line 402
|__asm___5_can_c_0fdded17____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_can_c_0fdded17____RRX|
#line 587
|__asm___5_can_c_0fdded17____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
